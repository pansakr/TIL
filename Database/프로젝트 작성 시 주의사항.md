### 정합성 깨짐 예시

<img src = "" alt = "정합성">

* auto_renewal_cycle, end_date, next_billing_date 세 가지를 동시에 저장하면 정합성이 깨질 가능성이 높다


* 각 컬럼의 의미

    - auto_renewal_cycle
    
        - 자동 갱신 주기

        - start_date + auto_renewal_cycle -> next_billing_date(다음 결제일) 계산 가능

    - end_date

        - 현재 구독의 만료일

        - start_date + auto_renewal_cycle -> end_date 계산 가능

    - next_billing_date

        - 다음 결제 예정일

        - end_date 와 동일하거나 start_date + auto_renewal_cycle 로 계산 가능

    - 위 세 가지는 서로 종속 관계에 있으므로 하나를 바꾸면 나머지 둘도 반드시 같이 갱신해야 논리적으로 일관성이 유지된다


* 정합성이 깨지는 예시

    - auto_renewal_cycle = "1개월" 일 때

    ```sql
    변경 시점       start_date  auto_renewal_cycle  end_date    next_billing_date
    초기 구독       2025-10-01  1개월                2025-11-01 2025-11-01    
    ```

    - auto_renewal_cycle = "3개월" 로 변경

    ```sql
    변경 시점       start_date  auto_renewal_cycle  end_date    next_billing_date
    3개월로 변경    2025-10-01  3개월                2025-11-01 2025-11-01    

    // auto_renewal_cycle 를 3개월로 변경
    // 하지만 end_date와 next_billing_date 는 변경하지 않아서 데이터 불일치가 발생하게 됨 
    ```

* 핵심 정보만(start_date, billing_cycle, auto_renew) 저장하고 다른 날짜는(end_date, next_billing_date) 필요할 때 비즈니스 로직에서 계산하거나 캐시용 컬럼으로 둬서 자동으로 관리하게 하는게 안전하다

* 캐시용 컬럼

    - 계산 결과를 미리 저장해 두는 컬럼

    - 다른 컬럼 값으로부터 계산될 수 있는 데이터를 조회 성능을 높이거나 편의성을 위해 미리 저장해 두는 것

    - 다음 결제일을 매번 애플리케이션에서 계산할 수도 있지만, DB에 저장해두면 처리하기 편해진다

    - 다만 정합성이 깨질 위험이 생기기 때문에 자동 갱신 구조를 둬서 관리해야 한다

* 비즈니스 로직에서 세 컬럼을 동시에 갱신하도록 한다면?

    - 업데이트 경로가 여러개일 때 한 군데라도 세 컬럼을 같이 안 바꾸면 바로 불일치 발생 

    - 모든 업데이트 경로에서 '세 컬럼을 동시에 갱신한다' 를 보장하기 위해 드는 비용이 늘어남 (테스트 케이스 등)

    - 구조적으로 정합성이 깨지지 않도록 만드는게 훨씬 안전함
 
### 제약 조건 네이밍

<img src = "" alt="제약조건 네이밍">
