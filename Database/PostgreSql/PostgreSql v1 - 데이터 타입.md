### 데이터 타입


#### 문자

* char(n) : n 에 따라 길이가 고정된 열이 생성된다. n보다 적게 입력하면 나머지 공간을 공백으로 채운다

* varchar(n) : 최대 길이가 n인 가변 길이 열이 생성된다. n보다 적게 입력해도 공백을 추가하지 않는다

* text : 길이 제한이 없는 가변 길이 열이 생성된다


#### 숫자 - 정수

* smallint : 2바이트

* integer : 4바이트

* bigint : 8바이트


#### 자동 증가 정수 1 - serial

* 1부터 시작해서 행이 생성될때마다 1씩 증가하여 지정한 정수 유형의 최대값까지 증가시키는 특별한 타입

* smallserial 2바이트

* serial 4바이트

* bigserial 8바이트


#### 자동 증가 정수 2 - Identity

* 다른 데이터베이스 시스템과 호환되고 자동 증가 열에 실수로 값을 삽입하지 않도록 방지한다

```
// 컬럼이름 정수타입 GENERATED ALWAYS AS IDENTITY - 사용자가 해당 열에 값 할당 불가

// 컬럼이름 정수타입 GENERATED BY DEFAULT AS IDENTITY - 사용자가 해당 열에 값 할당 가능
                                                        그렇기 때문에 PK로 사용하면 값이 중복될 수 있음
```

#### 숫자 - 고정 소수점

* 실수를 정수자리와 소수 자리로 나눠 소수점을 고정시켜 표현하는 방법

* 16비트라면 앞의 8비트는 정수, 뒤의 8비트는 소수로 표현한다

* 표현 가능한 수가 적고 제한된 부분에서만 사용한다

* numeric, decimal 가변적 길이 - 소수점 앞 131072, 뒤 16383

```
// numeric(precision, scale) precision에 입력될 전체 자리수, scale에 소수접 아래 자리수가 들어간다

// 총 다섯 자리에 소수점 아래로 두 자리를 사용한다고 하면 numeric(5, 2) 로 지정한다
```


#### 숫자 - 부동 소수점

* 소수점의 위치를 고정시키지 않고 표현하는 방법

* real 4바이트 - 소수점 뒤 6자리의 숫자

* double precision 8바이트 - 소수점 뒤 15자리의 숫자

* 연산 결과가 부정확 하기 때문에 정확해야 하는 계산은 고정 소수점 방식을 쓰는것이 좋다


#### 날짜와 시간

* date 4바이트 - 날짜

* time 8바이트 - 시간

* timestamp 8바이트 - 날짜와 시간. with time zome 키워드와 함께 사용할 수 있다
```
CREATE TABLE date_time_types (
    timestamp_column timestamp with time zone,
    interval_column interval
);

// with time zone 사용 시 time zone 리스트 추가 ex) EST, UTC와 시간 차이를 숫자로 입력
// 날짜, 시간 입력 시 국제 표준 형식 YYYY-MM-DD HH:MM:SS 에 맞춰준다
INSERT INTO date_time_types
VALUES
    ('2022-12-31 01:00 EST','2 days'), 
    ('2022-12-31 01:00 -8','1 month'), 
    ('2022-12-31 01:00 Australia/Melbourne','1 century'),
    (now(),'1 week');

// 결과 화면
2022-12-31 15:00:00.000 +0900	2 days // EST는 동부 표준시로 -5다
2022-12-31 18:00:00.000 +0900	1 mon
2022-12-30 23:00:00.000 +0900	100 years
2023-08-12 23:05:28.167 +0900	7 days

// 1 ~ 3 행에 01:00로 추가했는데 시간이 모두 다르게 나온다
// 이것은 사용자 국가/지역 시간대로 바꿔서 나타내 주기 때문인데 한국이라서 UTC 기준으로 +09가 표기되었다
// 첫번째 행은 EST로 저장했는데 이것은 동부 표준시로 UTC기준 -5이다
// 이것을 한국시로 바꿔주면 EST -> UTC로 +5, UTC -> 한국시로 +9 해서 +14이고 01:00 + 14시간은 15:00 이다
```

* interval 16바이트 - 날짜, 시간 길이 지정(10일, 6시간 등). 날짜나 시간 열의 계산에 사용된다
```
// 위에서 생성한 date_time_types 테이블을 사용한다
SELECT
    timestamp_column,
    interval_column,
    timestamp_column - interval_column AS new_date
FROM date_time_types;

//결과 화면
timestamp_column                interval_column   new_date
2022-12-31 15:00:00.000 +0900	2 days	          2022-12-29 15:00:00.000 +0900
2022-12-31 18:00:00.000 +0900	1 mon	          2022-11-30 18:00:00.000 +0900
2022-12-30 23:00:00.000 +0900	100 years	      1922-12-30 23:00:00.000 +0900
2023-08-12 23:05:28.167 +0900	7 days	          2023-08-05 23:05:28.167 +0900

// timestamp_column컬럼의 각 행의 날짜로부터 interval_column 컬럼의 interval 데이터 타입으로 표시된 시간 단위를 뺀다

// 결과 열은 timestamp with time zome 타입으로 포맷된다
```  


#### Timezome

* 특정 국가/지역 에서의 시간

* UTC(협정 세계 시)를 기준으로 +/- 해서 UTC와 시간의 차이를 구분한다

* KST(Korea Standard Time) UTC+09:00 - UTC를 기준으로 9시간 +

```
// 영국사람과 한국사람이 08:00AM에 온라인 약속을 잡았는데 Timezome 을 지정하지 않는다면 둘은 영원히 만나지 못한다

// 나라별로 시간이 다르기 때문인데 영국과 한국의 시간 차이는 + 9시간으로 영국이 오전 8시일때 한국은 오후 5시이다

// 그래서 기준을 정해야 하는데 그때 사용되는것이 Timezome이다. 특정 국가나 지역에서의 시간을 의미한다
```


### 타입 변환

* CAST(컬럼 as 변환할 타입), 컬럼 :: 변환할 타입 을 사용해 변환한다

* CAST(a AS b) - a를 b로 변환하는데 a컬럼의 데이터가 b타입에 포함될 수 있을때만 사용 가능하다

```
// 실수를 정수, 문자로 변환
SELECT numeric_column,
       CAST(numeric_column AS integer),
       CAST(numeric_column AS text)
FROM number_data_types

// 문자는 숫자가 될 수 없기 때문에 오류난다
SELECT CAST(char_column AS integer) FROM char_data_types;

// as 대신 ::도 가능하다
SELECT timestamp_column::varchar(10)
FROM date_time_types;
```
