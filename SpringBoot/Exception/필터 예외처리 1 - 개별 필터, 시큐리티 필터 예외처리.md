### 필터 예외처리

* 필터에서 발생한 예외는 @ControllerAdvice 에서 잡지 못한다

    - @ControllerAdvice는 내부적으로 ExceptionHandlerExceptionResolver를 통해 동작

    - 디스패처 서블릿이 핸들러(컨트롤러)를 실행하는 과정에서 발생하는 예외를 처리하도록 설계되어 있다

    - 필터에서 예외가 발생하면 디스패처 서블릿 실행 전이므로 @ControllerAdvice 에서 처리 불가능

* 필터 실행 순서

    ```
    Filter Aa
        → Filter B
            → Filter C
                → DispatcherServlet
    ```

* 필터 구조

    ```java
    public void doFilter(req, res, chain) {
        // 전처리
        chain.doFilter(req, res);
        // 후처리
    }
    ```

* 필터에서 예외 발생 시

    ```java
    public void doFilter(req, res, chain) {
        if (bad) {
            throw new RuntimeException("boom");
        }
        chain.doFilter(req, res);
    }
    ```

* 필터에서 발생한 예외 흐름

    - 정상 요청 시 흐름

        ```
        클라이언트
            ↓
        Tomcat
            ↓
        Filter A
            ↓
        Filter B
            ↓
        Filter C  
            ↓
        DispatcherServlet
            ↓
        Controller
            ↓
        ..
        ```

    - 필터에서 예외 발생 시 흐름

        ```
        클라이언트
            ↓
        Tomcat
            ↓
        Filter A
            ↓
        Filter B   ← 예외 발생
            ↓
        Filter A
            ↓
        Tomcat
            ↓
        /error 경로로 요청
            ↓
        BasicErrorController
        ```

        - DispatcherServlet 이 컨트롤러를 호출하는 과정까지 넘어가지 않았기 때문에 @ControllerAdvice 에서 예외 처리 불가능

        - 필터에서 별도로 에외처리를 하지 않았다면 예외는 톰캣까지 올라오고, 톰캣은 설정된 경로 /error 로 재요청

        - 해당 요청을 스프링의 기본 예외 처리 컨트롤러인 BasicErrorController 가 받아서 처리

* 필터에서 예외 처리

    - 필터 내부에서 직접 예외 처리

        ```java
        try {
            filterChain.doFilter(request, response);

        } catch (Exception e) {
            ...
        }
        ```

    - 또는 필터에서 예외를 처리하지 않고 톰캣으로 던져서 /error 을 호출하게 해 스프링 부트의 기본 에러 페이지 응답하기

### 시큐리티 필터 예외처리

* Spring Security 에는 예외적으로 보안 예외를 가로채기 위한 ExceptionTranslationFilter 가 존재한다

    - 시큐리티 필터에서 보안 예외가(인증(401), 인가(403) 등) 발생한 경우 ExceptionTranslationFilter 에서 처리

    - ExceptionTranslationFilter 는 Spring Security 가 필터체인에 자동으로 등록한다

        - 필터를 빈으로 등록할 때 return 에 httml.build() 시 Security 가 자동으로 구성

        - ExceptionTranslationFilter 를 직접 클래스로 작성해서 필터에 등록하는 경우는 거의 없다

            - 예외 필터라 순서가 정확해야 하는데, 직접 등록하면 정확한 위치를 찾기 어려움 

            - Security 가 내부적으로 정확한 위치에 자동 배치함

        - 개발자는 ExceptionTranslationFilter 가 예외 시 호출할 핸들러만 작성하면 된다

- 인증 예외 (AuthenticationException)

    - 사용자가 인증이 필요한 URL 에 접근했을 때 인증되지 않았다면 AuthenticationException 발생

    - 예외가 위로 전파되다가 ExceptionTranslationFilter 가 catch

    - 정책에 따라 적절한 예외처리(리다이렉트 또는 예외 객체 응답 등) 후 요청 종료됨

        - 웹 : 리다이렉트
        
        - API : 401 + 예외 응답객체(JSON) 

* 인가 예외 (AccessDeniedException)

    - 로그인은 했는데 권한이 부족할 때 발생

    - 특정 권한이 필요한 URL 에 접근했을때 필요한 권한이 없다면 AccessDeniedException 발생

    - 예외가 위로 전파되다가 ExceptionTranslationFilter 가 catch

    - 현재 사용자가 익명이라면 로그인 페이지로 유도

        - 권한이 있는 사용자이지만 로그인이 안 된 것일 수도 있기 때문

    - 현재 사용자가 로그인 상태면 AccessDeniedHandler 호출

    - AccessDeniedHandler 가 응답 생성 후 요청 종료됨

        - 웹 : 403 에러 페이지 html 
        
        - API : 403 + 예외 응답객체(JSON)

- 예시

    - API 응답용 예외처리

        ```java
        @Bean
        @Order(1)
        public SecurityFilterChain apiFilter(HttpSecurity http) throws Exception {

            http
                ...

                // Spring Security 에서 발생하는 예외 처리 설정
                .exceptionHandling(ex -> ex

                        // 인증(401) 예외 발생 시 호출
                        .authenticationEntryPoint(apiAuthenticationEntryPoint)

                        // 인가(403) 예외 발생 시 호출
                        .accessDeniedHandler(apiAccessDeniedHandler)
                )

            return http.build();
        }
        ```
        ```java
        @Component
        @RequiredArgsConstructor
        public class ApiAuthenticationEntryPoint implements AuthenticationEntryPoint {

            private final ObjectMapper objectMapper;

            @Override
            public void commence(HttpServletRequest request,
                                HttpServletResponse response,
                                AuthenticationException authException) throws IOException, ServletException {

                ErrorResponse body = ErrorResponse.of(BusinessErrorCode.AUTH_REQUIRED, request.getRequestURI());

                response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
                response.setContentType("application/json;charset=UTF-8");

                objectMapper.writeValue(response.getWriter(), body);
            }
        }
        ```
        ```java
        @Component
        @RequiredArgsConstructor
        public class ApiAccessDeniedHandler implements AccessDeniedHandler {

            private final ObjectMapper objectMapper;

            @Override
            public void handle(HttpServletRequest request,
                            HttpServletResponse response,
                            AccessDeniedException accessDeniedException) throws IOException, ServletException {

                ErrorResponse body = ErrorResponse.of(BusinessErrorCode.ACCESS_DENIED, request.getRequestURI());
                response.setStatus(HttpServletResponse.SC_FORBIDDEN);
                response.setContentType("application/json;charset=UTF-8");

                objectMapper.writeValue(response.getWriter(), body);

            }
        }
        ```

        - 시큐리티 관련 필터에서 예외 발생 시 ExceptionTranslationFilter 가 exceptionHandling() 호출  

        - 발생한 예외 종류에 따라 authenticationEntryPoint(), accessDeniedHandler() 가 호출됨

            - authenticationEntryPoint() 는 AuthenticationEntryPoint(인터페이스) 타입 을 호출

            - accessDeniedHandler() 는 AccessDeniedHandler() 타입을 호출

            - 해당 인터페이스들을 구현한 클래스가 실제로 실행되고, 그 내부의 로직이 응답을 생성

            - API 응답이 목적이니 예외 응답 객체 생성 후 JSON 으로 변환해 응답 body 에 담도록 구현됨

    - WEB 응답용 예외처리
    
        ```java
        @Bean
        @Order(2)
        public SecurityFilterChain webFilter(HttpSecurity http) throws Exception {

            http
                ...
                .exceptionHandling(ex -> ex

                    // 인증(401) 예외 시 호출
                    .authenticationEntryPoint((request, response, authException) -> {
                        response.sendRedirect("/login?messageKey=auth.required");
                    })

                    // 인가(403) 예외 시 호출
                    .accessDeniedHandler((request, response, accessDeniedException) -> {
                        response.sendRedirect("/access-denied");
                    })
                );

            return http.build();
        }
        ```

### 인터셉터 에외처리

* 인터셉터의 preHandle, postHandle 에서 발생한 예외는 @ControllerAdvice 에서 잡지 못한다

* preHandle

    - 컨트롤러가 호출되기 전에 실행

    - preHandle 에서 예외 발생 시 디스패처 서블릿은 컨트롤러를 실행하지 않고 즉시 예외를 밖으로 던짐

    - 컨트롤러 호출 단계로 진입하지 못했기 때문에 @ControllerAdvice 가 예외를 처리하지 못함

* postHandle

    - 컨트롤러 실행이 끝난 후 실행

    - 컨트롤러 실행이 끝난 시점이기 때문에 @ControllerAdvice 가 처리할 수 있는 타이밍을 놓침
