### 필터 예외처리 2

* 각 필터에서 처리하지 못해서 올라오는 예외들을 최종적으로 처리해주는 필터

    ```java
    @RequiredArgsConstructor
    public class ApiGlobalExceptionFilter extends OncePerRequestFilter {

        private final ObjectMapper objectMapper;

        @Override
        protected boolean shouldNotFilter(HttpServletRequest request) {
            // API만 처리 (그 외는 스프링 기본 에러 페이지/흐름으로)
            return !request.getRequestURI().startsWith("/api/");
        }

        @Override
        protected void doFilterInternal(HttpServletRequest request,
                                        HttpServletResponse response,
                                        FilterChain filterChain) throws ServletException, IOException {

            try {
                filterChain.doFilter(request, response);

            } catch (Exception e) {

                // 이미 401/403 등 응답이 만들어졌으면(커밋됐으면) 손대지 말 것
                if (response.isCommitted() || response.getStatus() != HttpServletResponse.SC_OK) {
                    throw e;
                }

                // 여기부터는 "아무도 처리 못한 예외" -> API는 JSON으로 통일
                // (선택) 로그
                // log.error("[API Unhandled Exception] {} {} {}", request.getMethod(), request.getRequestURI(), e.getMessage(), e);

                BusinessErrorCode code = BusinessErrorCode.INTERNAL_SERVER_ERROR;

                // (선택) 예외별로 code 매핑하고 싶으면 여기서 분기
                // if (e instanceof IllegalArgumentException) code = BusinessErrorCode.INVALID_INPUT_VALUE;

                ErrorResponse body = ErrorResponse.of(code, request.getRequestURI());

                response.resetBuffer();
                response.setStatus(code.getHttpStatus().value());
                response.setCharacterEncoding("UTF-8");
                response.setContentType(MediaType.APPLICATION_JSON_VALUE);

                objectMapper.writeValue(response.getWriter(), body);
                response.flushBuffer();
            }
        }
    }
    ```

    - 하위 필터에서 예외 응답이 정상적으로 만들어졌다면 catch 는 실행 안되고 클라이언트에게 응답

        - 하위 필터에서 401, 403 등 특정 예외를 처리해 응답을 만들도록 구성한 경우

        - 예외를 처리해 응답을 생성했으니 최 외곽 필터에는 예외가 전달되지 않으므로 catch 실행 안됨 

    - 하위 필터에서 예상하지 못한 예외 발생 시 catch 실행

        - 하위 필터에서 처리하지 않은 예외(네트워크 오류 등) 발생 시 최 외곽 필터의 catch 가 해당 예외를 잡아서 실행됨

        - 이때 응답이 만들어졌다면 다시 던짐

            - response.isCommitted() == true 이면 응답은 이미 만들어졌지만 예상치 못한 예외가 발생한 것

            - 예시

                - 하위 필터에 401 에 대한 예외처리 로직을 작성해 둠

                - 401 예외 발생 -> 예외처리 로직이 실행되어 예외 응답 생성 -> response.isCommitted() == true 로 변경됨

                - 이때 네트워크 연결이 갑자기 끊겨서 예상하지 못한 또 다른 예외가 발생

                - 최 외곽 필터로 예외가 올라옴

                - response.isCommitted() == true 이므로 예외 처리하지 않고 던짐

                - 이미 만들어진 예외 응답이 클라이언트에게 전달됨

                - 만약 응답이 이미 만들어졌는데 예외 응답을 또 만들게 되면 클라이언트 입장에서는 이상한 응답을 받게 됨

            - response.getStatus() != HttpServletResponse.SC_OK

                - 응답 생성 후 isCommitted == true 로 바뀌기 전 다른 예외가 추가로 발생해서 최 외곽 필터로 예외가 올라오는 경우를 방지하기 위한 코드

                - 이 경우 응답이 만들어져도 isCommitted 이 아직 false 라서 응답을 또 만드는 현상이 발생한다

                - 이때 상태코드 200 이 아닌 경우를 확인하게 만들면 위와 같은 경우를 방지할 수 있다

                    - 하위 필터에서 예외 발생 후 응답 생성 시 상태 코드는 200 이 아니기 때문 


* 응답 직접 생성 대신 예외처리기 재사용

    ```java
    @RequiredArgsConstructor
    public class ApiGlobalExceptionFilter extends OncePerRequestFilter {

        private final HandlerExceptionResolver handlerExceptionResolver;

        @Override
        protected boolean shouldNotFilter(HttpServletRequest request) {
            return !request.getRequestURI().startsWith("/api/");
        }

        @Override
        protected void doFilterInternal(HttpServletRequest request,
                                        HttpServletResponse response,
                                        FilterChain filterChain) throws ServletException, IOException {
            try {
                filterChain.doFilter(request, response);
            } catch (Exception e) {

                if (response.isCommitted()) {
                    throw e;
                }

                // RestControllerAdvice 재사용
                handlerExceptionResolver.resolveException(request, response, null, e);
            }
        }
    }
    ```

    - 컨트롤러에서 예외 발생 시 호출하는 HandlerExceptionResolver 재사용

        - 필터에서 예외 발생 시 HandlerExceptionResolver 을 필터에서 직접 호출

        - 컨트롤러처럼 내부 재요청 방식이 아니라 필터에서 예외처리기만 직접 호출하는 방식
