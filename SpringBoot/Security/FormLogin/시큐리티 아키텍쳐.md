#### 시큐리티

<img src="https://raw.githubusercontent.com/pansakr/TIL/refs/heads/main/%EC%9D%B4%EB%AF%B8%EC%A7%80/Spring/Security/%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0%20%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90.jpg" alt="시큐리티 아키텍쳐">

* 사용자가 로그인 요청을 보낸다

  ```
  POST /login
  username=xxx
  password=yyy
  ```

* AuthenticationFilter(인터페이스) 를 구현한 UsernamePasswordAuthenticationFilter 가 요청을 가로챈다

  - 요청이 설정된 형식에 맞다면, id, password 를 추출해 인증되지 않은 UsernamePasswordAuthenticationToken (미인증 상태의 토큰) 객체를 생성
 
    ```java
    UsernamePasswordAuthenticationToken (authenticated = false)
    ``` 

  - 해당 필터는 POST /login 요청만 받도록 설정되어(default) 있다 (설정에서 바꿀 수 있음)
 
  *UsernamePasswordAuthenticationFilter : 폼 기반 로그인에서 아이디, 비밀번호를 사용해서 인증하는 데 특화된 구현 클래스

* 생성된 미인증 토큰을 AuthenticationManager (인터페이스) 에게 전달하며 인증을 위임한다

  ```
  // 예시
  ProviderManager.authenticate(UsernamePasswordAuthenticationToken)
  ```

  - AuthenticationManager(인터페이스) 의 구현체가 ProviderManager 이므로 ProviderManager 에게 미인증 토큰이 전달된다
 
  - ProviderManager
 
    - 최상위 인증 관리자 (AuthenticationManager) 를 구현한 클래스
 
    - 역할

      - 인증 요청 위임: UsernamePasswordAuthenticationFilter 같은 인증 필터로부터 인증 요청(Authentication 객체)을 받는다
        
      - 적절한 Provider 찾기: 자신이 관리하는 여러 AuthenticationProvider 중에서 현재 들어온 인증 요청을 처리할 수 있는 Provider를 찾는다
  
      - 결과 반환: 선택된 Provider가 반환한 최종 인증 결과(Authentication 객체, 즉 인증된 사용자 정보)를 필터로 돌려보낸다
     
  - AuthenticationProvider
 
    - 사용자의 인증 정보를 검증하는 구체적인 로직을 구현하는 인터페이스

    - 역할
   
      - 실제 검증 : ProviderManager로부터 위임받은 인증 정보(예: 아이디/비밀번호)를 사용하여 데이터베이스나 외부 시스템과 비교하여 사용자를 검증
     
      - 성공 시 : 사용자의 권한(Role, Authority) 정보가 포함된 완전히 인증된(authenticated=true) Authentication 객체를 반환
     
      - 실패 시 : AuthenticationException을 발생
     
* ProviderManager 는 전달받은 토큰을 처리할 적절한 AuthenticationProvider(인터페이스) 를 찾는다

  - AuthenticationProvider 의 구현체 중 하나인 DaoAuthenticationProvider 가 실제 인증 로직을 수행한다
 
    - DaoAuthenticationProvider : 스프링 시큐리티의 기본 id, password 인증을 처리하는 클래스
  
  - DaoAuthenticationProvider 는 토큰의 username, password 와 DB 에 저장된 사용자 정보를 비교한다
 
    - 인증을 위해 토큰 내의 사용자 이름(Principal)을 사용하여 실제 시스템의 사용자 정보를 불러옴
   
      - UserDetailsService 인터페이스의 loadUserByUsername() 메소드를 호출
     
          ```java
          // 내부 동작
          UserDetailsService.loadUserByUsername()
          ```
     
      - loadUserByUsername() 호출 시 개발자가 구현한 로직에 따라 DB 에서 사용자의 정보를 UserDetails 객체 형태로 가져옴
     
    - 비밀번호 일치 여부 검증
   
      - DB 에서 가져온 비밀번호와 사용자가 입력한 비밀번호를 비교
     
      - 비밀번호는 암호화되어 저장되어 있으므로 PasswordEncoder 인터페이스를 사용해 확인
 

 
    - username 은 UserDetailsService, password 는 PasswordEncoder 사용
   
  - 성공
  
    - 사용자의 권한(Authorities) 정보가 포함된, 완전히 인증된(authenticated=true) 새로운 Authentication 객체를 ProviderManager에게 반환
  
    ```java
    // 예시
    UsernamePasswordAuthenticationToken (authenticated = true)
    ```

  - 실패
 
    - BadCredentialsException 또는 UsernameNotFoundException 같은 AuthenticationException 타입 예외 발생

* 성공 시 인증된 Authentication 객체가 UsernamePasswordAuthenticationFilter 까지 반환됨

* UsernamePasswordAuthenticationFilter 는 SecurityContextHolder에 Authentication 객체 저장

  - 현재 인증된 사용자의 정보를 스프링 시큐리티 세션(SecurityContextHolder)에 저장
 
  ```java
  // 내부적으로 처리되는 과정
  1. HttpSession이 없으면 request.getSession(true) 호출

  2. 세션 생성됨

  3. SecurityContext를 세션에 저장
  ```
