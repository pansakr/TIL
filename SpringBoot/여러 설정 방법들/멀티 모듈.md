### 멀티 모듈 프로젝트란

* 여러 모듈을 하나의 프로젝트 안에 담아 상호작용을 통해 서비스를 구성하는 것

* 하나의 프로젝트 안에 있기 때문에 필요한 모듈의 기능을 다른 모듈에서 가져다 쓸 수 있다.

* 하나의 모듈에 정의된 도메인을 다른 모듈에서 사용할 수 있다.

* entity뿐만 아니라 repository 등을 모두 사용할 수 있기 때문에 동일성 보장뿐만 아니라 중복 코드를 줄일 수 있다.


### 모듈

* 프로그램을 구성하는 시스템을 각각의 기능 단위의 독립적인 부분으로 분리한 것

* 패키지의 한 단계 위의 집합체이며, 관련된 패키지와 리소스들의 재사용할 수 있는 모음

* 독립적으로 배표될 수 있는 코드의 단위


### 멀티 모듈 프로젝트를 적용하는 이유

* 작은 단위에서 시작된 프로젝트들은 시간이 지날수록 기능이 추가되면서 점점 커지고 복잡해진다.

* 기능이 많아지고, 요청이 많아질수록 그 요청들을 하나의 프로그램에서 처리하기 어려워지기 시작한다.

* 때문에 하나로 운영하던 서비스가 클라이언트 서비스와 운영 시스템으로 나뉘는 등의 분리가 일어나게 된다.

* 분리가 되어도 회원에 대한 도메인은(entity) 각각의 프로젝트에서 동일성을 보장해야 한다.

* 하지만 별개의 두 개의 프로젝트로 나뉘었기 때문에 각각의 코드로 관리될 것이고, 한쪽에서 도메인(entity)를 수정했다면 다른 쪽에서도 똑같이 수정해줘야 한다.

* 한쪽만 수정하거나 잘못 수정해 도메인이 달라지는 경우 문제가 발생하게 된다.

* 이런 문제들을 해결하기 위해 멀티 모듈 프로젝트가 도입되었다.



### 멀티 모듈 프로젝트 구현 - gradle

#### 루트(단순히 프로젝트 이름. 다른 의미 없음) 프로젝트

* 루트 프로젝트는 모듈들을 담는 역할만 하기 때문에 src 폴더를 제거한다

* 루트 프로젝트 build.gradle

``` java
// 빌드과정에 필요한 기본정보
plugins {
	id 'java'
	id 'org.springframework.boot' version '2.7.9'
}

// bootJar 작업은 실행 가능한 jar을 생성하려고 시도하기 때문에 main() 메서드가 필요하다
// 그러나 Root 프로젝트는 main 없이 라이브러리의 역할을 하는 모듈이기 때문에 false로 비활성화 해준다.
bootJar { enabled = false }

// settings.gradle에 include된 프로젝트 전부에 대한 공통 사항을 명시한다
// 이 블록 안에서는 plugins 블록을 사용할 수 없으므로 apply plugin을 사용한다.
subprojects {
	group = 'com.example'
	version = '0.0.1-SNAPSHOT'
	sourceCompatibility = '11'

	apply plugin: 'java'
	// build.gradle에서 api() 를 사용하려면 java-library 사용
	apply plugin: 'java-library'
	apply plugin: 'org.springframework.boot'
	// spring boot dependency를 사용하여 사용중인 부트 버전에서 자동으로 의존성을 가져온다.
	apply plugin: 'io.spring.dependency-management'

	configurations {
		compileOnly {
			extendsFrom annotationProcessor
		}
	}

	// 각종 의존성(라이브러리)들을 어떤 원격 저장소에서 받을 것인지 정해준다.
	repositories {
		mavenCentral() // Android Studio의 Gradle 플러그인용 저장소
	}

	// 관리하는 모듈들에 공통 의존성을 추가시킨다
	dependencies {
		implementation 'org.springframework.boot:spring-boot-starter'
		compileOnly 'org.projectlombok:lombok'
		annotationProcessor 'org.projectlombok:lombok'
		testImplementation 'org.springframework.boot:spring-boot-starter-test'
	}

	tasks.named('test') {
		useJUnitPlatform()
	}
}
```

* 루트 프로젝트 setting.gradle

```java
rootProject.name = 'root' // 프로젝트 이름을 root로 한것일뿐 다른 의미는 없다.
include 'client-module'
include 'admin-module'
include 'core-module'
```

#### 루트 프로젝트 하위 core-module

* core-module은 실행이 필요 없기 때문에 main.java가 없다.

* build.gradle

```java
// core 모듈의 경우 main 메서드 없이 라이브러리 역할을 하는 모듈이다.
// 그러므로 BootJar이 아닌 jar파일로 생성되고 다른 프로젝트에 첨부될 것이다.
// 따라서 bootJar은 false, jar은 true로 설정한다.
bootJar { enabled = false }
jar { enabled = true }

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa:2.7.5'
}
```

### 멀티 모듈에서의 패키지 구조

* @ComponentScan이 적용된 클래스 하위 패키지부터 스캔하기 때문에 각 모듈들의 @ComponentScan이 적용된 위치를 잘 살펴봐야 한다.

```
// 하나의 프로젝트 패키지에 1, 2번 모듈이 멀티 모듈로 구성되어 있고 1번이 2번을 implement 하고 있다고 가정한다.

// 1번 모듈은 com - org - 1module - 1main.java 의 구조를 가지고 있다.

// 2번 모듈은 com - org - 2module - xxx.java 의 구조를 가지고 있다.

// 1번 모듈 실행 시 1main.java에 @ComponentScan이 있으므로 해당 클래스의 하위부터 ComponentScan을 한다.

// 그리고 멀티 모듈 구성 의도대로라면 2번 모듈의 클래스들이 실행되어야 하지만 경로 문제로 실행되지 않는다.

// 1main.java 하위 패키지부터 스캔하기 때문에 경로상 같은 위치에 있는 2번 모듈의 xxx.java는 스캔 범위에 포함되지 않기 때문이다.

// 이 문제를 해결하려면 실행하려는 모듈의 main.java의 경로를 당겨주면 된다.

// 1번 모듈을 com - org - 1module, 1main.java(1module과 같은 위치) 수정했다

// 이제 1module 하위 패키지 부터 스캔하기 때문에 2번 모듈의 xxx.java가 포함되어 실행된다. 
```
