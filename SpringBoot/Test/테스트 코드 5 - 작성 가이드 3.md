### 테스트 코드 작성 가이드 3

* Controller 계층 테스트

    - 테스트 대상 메서드 : UserRestController.signUp();

    - 성공 케이스

        ```java
        @WebMvcTest(controllers = UserRestController.class)
        @Import(GlobalExceptionHandler.class)
        class UserRestControllerTest {

            @Autowired
            private MockMvc mockMvc;

            @MockitoBean
            private UserService userService; // 컨트롤러가 의존하는 서비스는 mock 처리

            @Autowired
            private ObjectMapper objectMapper; // JSON 직렬화/역직렬화용

            @Test
            @WithMockUser // 가짜 인증 유저
            @DisplayName("회원가입 성공 시 201 상태코드와 JSON 응답을 반환한다")
            void signUp_success() throws Exception {
                // given
                UserRequest request = new UserRequest(
                        "user@test.com",
                        "123456",
                        "testName",
                        "testAddress",
                        "01012345600"
                );

                UserResponse response = new UserResponse(
                        "user@test.com",
                        "testName",
                        "testAddress",
                        "01012345600"
                );

                given(userService.signUp(any(UserRequest.class))).willReturn(response);

                String json = objectMapper.writeValueAsString(request);

                // when & then
                mockMvc.perform(post("/users")
                                .with(csrf())   // POST 요청 CSRF 추가
                                .contentType(MediaType.APPLICATION_JSON)
                                .content(json))
                        // 컨트롤러에서 ResponseEntity.status(HttpStatus.CREATED) 를 쓰면 isCreated()
                        // ok().body(...) 쓰면 isOk()
                        .andExpect(status().isCreated())
                        .andExpect(content().contentType(MediaType.APPLICATION_JSON))
                        .andExpect(jsonPath("$.email").value("user@test.com"))
                        .andExpect(jsonPath("$.name").value("testName"))
                        .andExpect(jsonPath("$.address").value("testAddress"))
                        .andExpect(jsonPath("$.phone").value("01012345600"));
            }

        }
        ```

        - @WebMvcTest

            - 웹 MVC 계층만 로딩하는 설정

            - @Controller, @RestController 등만 로드

            - controllers = UserRestController.class

                - 이 테스트에서는 UserRestController 만 로드

                - 다른 컨트롤러는 제외

        - MockMvc

            - 가짜 HTTP 요청/응답을 만들어서 컨트롤러를 테스트하는 도구

            - GET /users, POST /users 같은 요청 시뮬레이션 가능

            - 응답 status, header, body(Json) 검증 가능

        - @MockitoBean

            - Mock 객체를 스프링 컨테이너에 Bean 으로 등록

                - @SpringBootTest, @WebMvcTest 등은 테스트에 스프링 컨테이너를 사용하므로 빈 등록 시 @MockBean 사용해야 함  

            - 컨트롤러 테스트, 통합 테스트 등은 실제 HTTP 요청 흐름, 스프링 MVC 동작 검증 등을 테스트 한다

            - 이때 스프링 MVC 가 자동 설정한 DispatcherServlet, HandlerMapping 등이 필요하고, 컨트롤러는 스프링 빈이어야 하기 때문에 스프링 컨테이너를 띄워야 한다

                - HandlerMapping 은 스프링 빈으로 등록된 컨트롤러만 스캔한다

                - 컨트롤러가 빈으로 등록되지 않으면 HandlerMapping이 그 컨트롤러를 HTTP 요청 처리 대상으로 인식하지 못하기 때문에 MockMvc 로 요청을 보내도 404 에러가 발생한다

            - 컨트롤러에 @MockitoBean 사용 시

                - 스프링 컨테이너에 mock 객체가 컨트롤러 대신 빈으로 등록됨

                - HandlerMapping 이 컨트롤러 빈을 스캔할 때 mock 객체를 보게 됨

                - 이 mock 객체에는 @PostMapping 등이 붙은 실제 메서드가 없다

                - 스프링 MVC 입장에서는 요청 매핑이 걸린 메서드가 하나도 없는 컨트롤러로 인식됨

                - MokMvc 로 POST /users 같은 요청을 보내면 받아줄 메서드가 없기 때문에 404 발생

        - @Mock
        
            - Mockito 가짜 객체 생성

            - 스프링을 사용하지 않는 순수 단위 테스트시 사용

            - 순수 자바로만 테스트 가능한 경우는 단위 테스트를 사용하는 것이 좋다

        - Objectmapper

            - Jackson 의 ObjectMapper

            - 자바 객체 -> Json 문자열로 변환할 때 사용

            - @WebMvc 사용시 빈으로 자동 등록됨 

            - 예시
    
                ```java
                // request 객체를 json 문자열로 직렬화
                String json = objectMapper.writeValueAsString(request);
                ```
        - @WithMockUser

            - 프로젝트에 스프링 시큐리티 의존성을 추가했다면 모든 요청에 인증을 요구하게 됨

            - 테스트에서 mockMvc 를 통한 가짜 요청도 인증이 없다면 실패함

            - 시큐리티를 무시하거나, 가짜 인증 유저를 사용하는 두가지 방법이 있다 

                - 테스트 시 시큐리티 필터를 전부 비활성화 하는 옵션을 사용

                    ```java
                    @AutoConfigureMockMvc(addFilters = false)
                    class UserRestControllerTest{...}
                    ```

                - 시큐리티를 유지하고 인증/CSRF 까지 테스트

                    ```java
                    @WithMockUser   // 가짜 인증 유저
                    @Test
                    void ...test(){

                        ...

                    mokMvc.perForm(post("/users")
                            .with(csrf()) // POST 요청 CSRF 추가
                    }

                    
                    ```

        - post("/users") : POST /users 요청 시뮬레이션

        - contentType(MediaType.APPLICATION_JSON) : 요청 본문 타입 : Json

        - content(json) : HTTP Body 에 위에서 만든 Json 문자열 넣음

        - andExpect() : 검증 부분

        - status().isCreated()
        
            - HTTP 상태 코드가 201 이어야 함

            - 컨트롤러에서 ResponseEntity.ok() 사용한다면 isCreated() 대신 isOk() 로 교체

        - content().contentType(MediaType.APPLICATION_JSON)

            - 응답의 Content-Type 이 Json 인지 확인

        - jsonPath("$.email")

            - 응답 Json 의 각 필드가 기대한 값인지 검증

    - 실패 케이스

        ```java
        @Test
        @DisplayName("이메일 중복 시 400 상태코드와 에러 JSON 응답을 반환한다")
        void signUp_emailDuplicated_shouldReturnBadRequest() throws Exception {
            // given
            UserRequest request = new UserRequest(
                    "dup@test.com",
                    "123456",
                    "dupName",
                    "dupAddress",
                    "01099998888"
            );

            // signUp 호출 시 UserException 발생하도록 mock 세팅
            given(userService.signUp(any(UserRequest.class)))
                    .willThrow(new UserException(BusinessErrorCode.EMAIL_DUPLICATED));

            String json = objectMapper.writeValueAsString(request);

            // when & then
            mockMvc.perform(post("/users")
                            .contentType(MediaType.APPLICATION_JSON)
                            .content(json))
                    .andExpect(status().isBadRequest())
                    .andExpect(content().contentType(MediaType.APPLICATION_JSON))
                    .andExpect(jsonPath("$.code").value(BusinessErrorCode.EMAIL_DUPLICATED.name()))
                    .andExpect(jsonPath("$.message").value(BusinessErrorCode.EMAIL_DUPLICATED.getMessage()));
                    // 필요하면 path, status 등 추가 검증 가능
                    // .andExpect(jsonPath("$.status").value(400))
                    // .andExpect(jsonPath("$.path").value("/users"));
        }
        ```
