### 테스트 코드 작성 가이드 1

* 서비스 계층 메서드 테스트

    - 테스트 대상 메서드 : DefaultUserService.signup()

    ```java
    @Getter
    @NoArgsConstructor
    @AllArgsConstructor
    public class UserRequest {

        @NotBlank(message = "이메일을 입력하세요")
        @Email(message = "이메일 형식이 올바르지 않습니다")
        private String email;

        @NotBlank(message = "비밀번호를 입력하세요")
        @Size(min = 6, max = 20, message = "비밀번호는 6 ~ 20 사이로 입력해 주세요")
        private String password;

        @NotBlank(message = "이름을 입력하세요")
        private String name;

        @NotBlank(message = "주소를 입력하세요")
        // @Max(50)
        private String address;

        @NotBlank(message = "휴대폰 번호를 입력하세요")
        @Pattern(
                regexp = "^010\\d{8}$",
                message = "하이픈(-) 을 빼고 입력하세요"
        )
        private String phone;

    }
    ```
    ```java
    @Service
    @RequiredArgsConstructor
    public class DefaultUserService implements UserService {

        private final UserQueryRepository userQueryRepository;
        private final UserRepository userRepository;
        private final PasswordEncoder encoder;

        /**
         * @param request : 사용자가 입력한 가입 정보
         * DB 조회 후 값이 없다면 가입, 값이 있다면 예외
         */
        @Transactional
        @Override
        public UserResponse signUp(UserRequest request) {

            validate(request);

            return UserMapper.toResponse(
                    userRepository.save(UserMapper.toEntity(request, encoder))
            );
        }

        /**
         * 검증 : 사용자가 입력한 가입 정보가 DB에 있으면 true (예외발생)
         */
        private void validate(UserRequest request){

            if (userQueryRepository.existsByEmail(request.getEmail()))
                throw new UserException(BusinessErrorCode.EMAIL_DUPLICATED);

            if (userQueryRepository.existsByPhone(request.getPhone()))
                throw new UserException(BusinessErrorCode.PHONE_DUPLICATED);
        }

    }
    ```
    ```java
    @Repository
    @RequiredArgsConstructor
    public class UserQueryRepository {

        private final JPAQueryFactory queryFactory;

        public boolean existsByEmail(String email) {

            return queryFactory
                    .selectOne()
                    .from(userEntity)
                    .where(userEntity.email.eq(email))
                    .fetchFirst() != null;
        }

        public boolean existsByPhone(String phone) {

            return queryFactory
                    .selectOne()
                    .from(userEntity)
                    .where(userEntity.phone.eq(phone))
                    .fetchFirst() != null;

        }
    }
    ```


* 테스트 설정

    ```java
    @ExtendWith(MockitoExtension.class) // 테스트에 추가 기능 적용시 사용
    class DefaultUserServiceTest {

        @Mock   // UserQueryRepository 에 가짜 객체 주입
        private UserQueryRepository userQueryRepository;

        @Mock
        private UserRepository userRepository;

        @Mock
        private PasswordEncoder encoder;

        @InjectMocks    // @Mock 로 생성한 가짜 객체들을 @InjectMocks 이 적용된 클래스에 주입
        private DefaultUserService userService;

        // ... 테스트 메서드들 ...
    }
    ```

    - @ExtendWith

        - 테스트에 추가 기능을 적용하고 싶을 때 사용 

        - @ExtendWith(MockitoExtension.class)

            - MockitoExtension.class 등록 시 테스트에 Mockito 프레임워크를 사용할 수 있음

                - Mockito : 가짜 객체를 쉽게 만들고 관리하게 해주는 도구

            - 테스트 실행 시 @Mock 필드에 가짜 객체를 주입하고, @InjectMocks 필드에 Mock 객체를 연결해 줌

            ```java
            // 이걸 Mockito 가 대신해 줌
            new DefaultUserService(userQueryRepository, userRepository, encoder);
            ```

* 정상 케이스 테스트

    ```java
    @Test
    void signUp_success() {

        // given
        UserRequest request = new UserRequest(
                "user@test.com", "123456", "testName", "testAddress", "01012345600"
        );

        given(userQueryRepository.existsByEmail(request.getEmail())).willReturn(false);
        given(userQueryRepository.existsByPhone(request.getPhone())).willReturn(false);

        given(encoder.encode(anyString())).willReturn("encoded_pw");

        User savedUser = new User(
                request.getEmail(),
                "encoded_pw",
                request.getName(),
                request.getAddress(),
                request.getPhone()
        );

        given(userRepository.save(any(User.class))).willReturn(savedUser);

        // when
        UserResponse response = userService.signUp(request);

        // then
        assertThat(response.getEmail()).isEqualTo("user@test.com");
        assertThat(response.getName()).isEqualTo("testName");

        verify(userRepository, times(1)).save(any(User.class));
    }
    ```

    - given : 테스트에 필요한 값 준비 단계

    - given(), willReturn() 메서드

        - Mock 로 주입한 객체가 특정 상황에서 어떻게 동작할지(행동) 정의

        - given() : 행동을 정의할 객체의 메서드

        - any() : 인자로 오는 타입을 제한하고, 타입만 맞다면 무엇이든 허용하는 메서드

        - willReturn() : 반환할 값 지정

        - 예시

            ```java
            // given() : userQueryRepository.existsByEmail() 호출 시 
            // willReturn() : false 반환
            given(userQueryRepository.existsByEmail(request.getEmail())).willReturn(false);
            ```

            - 위 케이스는 중복이 없는 성공 케이스이므로 false(중복되지 않음) 를 반환하도록 설정

            ```java
            // given() : encoder.encode() 가 어떤 문자열을 받든지 상관없이 호출되면
            // willReturn() : encoded_pw 문자열 반환
            given(encoder.encode(anyString())).willReturn("encoded_pw");
            ```

            - 암호화 로직은 이 테스트의 관심사가 아니라서 인코딩이 호출됬다는 사실과 결과값이 있다는 정도만 설정

            ```java
            // given() : userRepository.save 가 호출되고, User 타입의 객체가 인자로 사용되었다면
            // willReturn() : savedUser 반환
            given(userRepository.save(any(User.class))).willReturn(savedUser);
            ```

    - when
    
        - 테스트 실행 단계

        - 테스트 하려는 메서드 호출 

    - then : 검증 단계

        - assertThat()

            - 응답 객체에 대해 검증

            ```java
            // 응답 객체의 getEmail() 의 값이 기대한 값("user1@test.com") 과 같은지 체크
            assertThat(response.getEmail()).isEqualTo("user1@test.com");

            // 응답 객체의 getName() 의 값이 기대한 값("test1") 과 같은지 체크
            assertThat(response.getName()).isEqualTo("test1");
            ```

        - verify

            - 테스트 메서드 실행이 끝난 후, 테스트 대상 메서드가 특정 메서드를 호출했는지/안했는지 검증

            ```java
            // userRepository 타입의 Mock 객체의 save() 메서드가 정확히 1번 호출되었는지 확인
            verify(userRepository, times(1)).save(any(User.class));
            ```

* 예외 케이스 테스트

    ```java
    @Test
    void signUp_emailDuplicated_shouldThrowException() {
        // given
        UserRequest request = new UserRequest(
                "dup@test.com", "123456", "test", "주소", "01012345600"
        );

        // existsByEmail() 호출 시 true(중복됨) 반환
        // 이메일 중복 예외 케이스 테스트이므로 true 반환하도록 지정
        given(userQueryRepository.existsByEmail(request.getEmail())).willReturn(true);

        // when & then
        assertThatThrownBy(() -> userService.signUp(request))
                .isInstanceOf(UserException.class)
                .hasMessageContaining(BusinessErrorCode.EMAIL_DUPLICATED.getMessage());

        verify(userRepository, never()).save(any());
    }
    ```

    - when & then : 실행과 검증을 함께 묶는 스타일

        - assertThatThrownBy()

            - 예외 검증 메서드

            - 내부의 메서드를 실행했을 때 발생하는 예외를 검증

            ```java
            // assertThatThrownBy() : 내부의 람다 실행 시 발생하는 예외가
            assertThatThrownBy(() -> userService.signUp(request))

            // UserException 타입이어야 한다
            .isInstanceOf(UserException.class)

            // 예외 메시지에 EMAIL_DUPLICATED 에 해당하는 메시지가 포함되어 있어야 함
            // 예시 : EMAIL_DUPLICATED("이미 사용 중인 이메일 입니다")
            .hasMessageContaining(BusinessErrorCode.EMAIL_DUPLICATED.getMessage());
            ```

        - verify()

            ```java
            // userRepository 의 save() 메서드는 절대 호출되면 안됨
            verify(userRepository, never()).save(any());
            ```

            - 이메일 중복에서 이미 예외를 던졌기 때문에 저장 로직까지 내려가면 안 된다는 것
