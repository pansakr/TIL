### OSIV (Open Session In View)

* 데이터베이스 커넥션의 생존 범위를 지정하는 옵션

    - JPA의 실행 순서

        - 사용자의 요청 시 비즈니스 로직에서(주로 서비스 계층) 트랜잭션이 시작

        - DB 커넥션을 얻고, 엔티티 매니저 생성. 엔티티 매니저는 쓰레드 로컬에 생성되므로 멀티 쓰레드 환경에 안전

            - 엔티티 매니저는 영속성 컨텍스트를 관리(생성, 제거, 조회)

            - 엔티티 매니저 마다 고유한 영속성 컨텍스트를 가지며, 엔티티 매니저와 그로부터 생성된 영속성 컨텍스트는 트랜잭션 범위 내에서만 사용되고 트랜잭션 종료 시 같이 종료됨

        - DB 작업 처리 후 트랜잭션을 종료하고 커넥션을 종료 또는 커넥션 풀에 반환

    - OSIV 는 DB 커넥션과 영속성 컨텍스트의 생존 범위를 지정하는 옵션이다

        - 기본값은 true로 view 까지 DB 커넥션이 살아있고 응답하는 시점에 반환된다

            - 기본값 설정 시 서비스 계층에서 트랜잭션이 종료되어도 영속성 컨텍스트가 종료되지 않는다

            - view 나 Controller 에서 지연 로딩이 가능하게 된다

            - 다만 너무 오랫동안 DB 커넥션을 사용하기 때문에 실시간 트래픽이 중요한 애플리케이션에서는 커넥션이 모자랄 수 있다

                - 응답하는 시점에 DB 커넥션을 반환하기 때문에 컨트롤러에서 외부 API를 호출 시  커넥션을 반환하지 못하는 시간 외부 API 대기 시간 만큼 길어진다

        - false 설정

            - 트랜잭션 종료 시 엔티티 매니저와 영속성 컨텍스트를 종료하고 DB 커넥션 반환

                - 커넥션 리소스를 낭비하지 않음

            - 모든 지연로딩을 트랜잭션 안에서 처리해야 하며 컨트롤러와 view 템플릿에서 지연로딩이 동작하지 않는다

* 권장하는 방법

    - 핵심 비즈니스 로직과 최적화 쿼리를 분리하는 것

        - 보통 비즈니스 로직은 특정 엔티티를 등록하거나 수정하는 것으로 성능이 문제가 되지 않는다

        - 그러나 복잡한 화면을 출력하기 위한 쿼리는 그에 맞춰 성능 최적화가 중요하다

        - 그래서 둘을 분리해 사용하면 좋다

        ```java
        OrderService
        |
        |-  OrderService - 핵심 비즈니스 로직
        |
        |-  OrderQueryService - 성능 최적화 쿼리를 사용하는 서비스
        ```

* 하이버네이트만 있던 때는 Open Session In View, JPA 출시 이후 Open EntityManager In View 라고 한다

    - 관례상 OSIV 라고 한다
