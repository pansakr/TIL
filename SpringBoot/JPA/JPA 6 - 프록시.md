### jpa에서의 프록시

* 엔티티를 상속받아 만들어진 해당 엔티티의 참조(target 변수)를 가지고 있는 객체

* getReference() 로 특정 엔티티를 상속받은 프록시 객체를 생성할수 있고, 이 시점엔 겉모습만 같고 실제 데이터는 없다

* 만들어진 프록시 객체는 부모 엔티티와 같은 구조를 가지고 있으므로 구분하지 않고 사용하면 된다

```
// getReference()메서드 사용시 프록시 객체가 만들어진다
엔티티클래스 참조변수 = em.gerReference(엔티티클래스, 식별자)
```

* 프록시 객체의 get() 메서드로 데이터 조회시 jpa는 영속성 컨텍스트를 확인 후 프록시 객체에 해당하는 실제 엔티티가 없으면 db검색 후 엔티티를 생성 후 프록시 객체와 연결한다(초기화)

* 프록시 객체는 생성된 실제 엔티티 객체의 참조를 target 변수에 보관한다

* target으로 실제 엔티티에 접근해 조회 후 반환한다

* 프록시 객체의 초기화는 위 설명처럼 영속성 컨텍스트의 도움을 받기 때문에 준영속 상태라면 예외가 발생한다

* 프록시 객체는 식별자 값을 보관하므로 연관관계를 설정할 때 sql실행 횟수를 줄일 수 있다

* 프록시 객체는 주로 연관 엔티티의 지연 로딩에 사용한다


### 즉시 로딩과 지연 로딩

```
// A, B 클래스가 있고 A클래스에 B클래스를 참조하는 참조 변수 b 가 있다고 가정한다.

A a = em.find(A.class, "a클래스의 @Id")
B b = a.getB();  // A클래스의 참조변수 b로 B클래스에 접근해 데이터를 읽어 반환

// find로 조회할때 A클래스와 A가 참조하는 B클래스도 모두 읽어오는 것이 즉시로딩이다.
// find로 조회할때 A클래스만 읽어오고 B클래스를 실제 사용할 때 다시 DB를 조회해 읽어오는것이 지연로딩이다.
```

* 즉시 로딩은 한번 조회할때 참조하는 테이블까지 조인해서 한꺼번에 가져온다.

* 지연 로딩은 첫 조회시 참조 엔티티를 제외해 조회하고, 엔티티.get엔티티참조변수().get() 처럼 엔티티의 값을 실제 사용하는 시점에 데이터베이스에서 추가로 조회한다.


### 즉시 로딩

* 연관된 엔티티를 즉시 조회한다.

* @ManyToOne의 fetch 속성을 FetchType.EAGER로 지정한다.

* jpa는 선택적 비식별 관계일땐 외부 조인, 필수 관계면 내부 조인을 사용해 조회한다.

```
@JoinColumn(nullable = true) null 허용(기본값), 외부 조인 사용
@JoinColumn(nullable = false) null 허용하지 않음, 내부 조인 사용
```

* 내부 조인이 성능과 최적화에 유리하다


### 지연 로딩

* 연관된 엔티티를 프록시로 조회하고 실제 사용할때 초기화하면서 DB를 조회한다.

* 참조 엔티티를 제외해 조회하고 비어있는 참조변수 자리에 프록시 객체를 반환한다. 

* 참조 엔티티가 필요해서 반환되었던 프록시 객체를 사용했을때 DB를 조회해 해당하는 엔티티를 생성 후 프록시 객체가 참조해 데이터를 반환한다.

* 실제 사용될 때까지 데이터 로딩을 미뤄서 지연 로딩이라 한다.

* @ManyToOne의 fetch 속성을 FetchType.LAZE로 지정한다.


### 즉시로딩, 지연로딩 중 어떤것을 사용해야할까?

* jpa의 기본 fetch 전략은 연관 엔티티가 하나면 즉시로딩, 컬렉션이면 지연 로딩을 사용한다.

```
@ManyToOne, @OneToOne - 즉시 로딩
@OneTomany, @ManyToMany - 지연 로딩
```

* 연관 컬렉션에 데이터가 수만개일때 즉시 로딩이면 수만개의 데이터가 함께 로딩되기 때문에 컬렉션은 지연 로딩으로 설정하는것이 좋다.

* 추천 방법은 일단 모든 연관관계에 지연 로딩을 사용해 완성하고 실제 사용하는 상황을 보고 필요한 곳만 즉시 로딩으로 바꿔준다.
