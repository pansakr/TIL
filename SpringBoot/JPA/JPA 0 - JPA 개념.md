### 자바를 사용해 관계형 데이터베이스와 통신 하는 과정

* 자바는 객체를 사용하고 DB는 테이블을 사용한다

* 자바를 사용해 DB에 데이터를 저장하려면 개발자가 직접 자바의 객체를 테이블로 변환해줘야 했다

  - sql문을 직접 작성하고, jdbc를 사용해 객체의 필드를 작성해둔 sql문에 일일히 매핑
 
  - 완성된 sql을 DB로 보내고, 쿼리 결과 데이터를 다시 자바 객체로 변환   


### ORM(Object Relational Mapping)

*   객체와 테이블을 자동으로 매핑해주는 도구

  - 데이터베이스는 테이블 기반이지만, 객체 지향 언어는 클래스를 기반으로 한다. ORM은 이 두 모델 간의 불일치를 해결해 준다
   
  - 자바는 객체지향 패러다임이고, 관계형 데이터베이스는 데이터를 정규화해서 보관하는 것을 목표로 한다
  
  - ORM은 이러한 객체와 관계형 데이터베이스의 패러다임의 불일치를 개발자 대신 해결해준다

* ORM 이 패러다임의 불일치를 해결해주는 방법

  - 상속받거나 다른 객체를 참조하고 있는 객체를 DB에 저장할때 테이블 구조에 맞게 SQL을 개발자가 직접 작성해야 했던 것을 자동으로 처리해준다
  
  - 객체를 ORM 프레임워크에 저장하면 ORM 이 적절한 SQL 을 생성해 실행해준다
 
    - 이 부분을 통해 개발자가 SQL문을 직접 작성하지 않아도 DB와 상호작용이 가능하다
  
  - 즉 객체나 테이블은 서로를 신경쓸 필요 없이 각자의 목적에 맞게 모델링하면 ORM 이 자동으로 매핑해준다 
    
  *벤더(vendor) = 제품 판매인 또는 판매업체

  *매핑(mapping) = 어떤 데이터와 다른 데이터를 짝짓거나 연결해 저장하는 과정

### 패러다임 불일치

* 상속, 연관관계, 객체 그래프 탐색 문제 해결

* 객체와 관계형 데이터베이스는 목적이 다르므로 데이터를 저장하는 방법이 다르게 설계되어 있다

* 객체 구조를 테이블 구조에 저장하려면 패러다임의 불일치를 해결해 줘야하는데 그것이 개발자의 몫이었다

* 상속받은 객체를 테이블에 저장하려면 부모객체, 자식객체 따로 insert를 해줘야 한다

* 또 객체는 다른 객체를 자신의 필드로 참조해서 연관 객체를 조회하는데 테이블은 외래키를 사용해서 연관 테이블을 조인해 조회한다

* 객체는 참조 필드에 참조대상 객체정보가 들어있고, 테이블로 옮겨 저장하면 참조 필드가 외래키가 되는데 테이블의 외래 키는 객체와 달리 다른 테이블의 컬럼 하나만 참조할 수 있다

* 반대로 객체를 테이블에 맞추면 참조를 통해 객체를 찾을 수 없게 되어서 객체지향의 특징을 잃게 된다

* 객체지향의 특징을 가지면서 테이블에 저장하려면 참조를 외래키로 변환해야하고, 조회시 외래키를 참조로 변환해서 가져와야 한다

* 이 과정이 패러다임 불일치를 해결하기 위해 소모하는 비용이다

*패러다임 - 이론적인 틀이나 체계

### JPA(Java Persistence API)

* 자바에서 제공하는 ORM 의 표준 명세 (구현체 x)

* JPA는 ORM의 인터페이스를 모아둔 것이고, 이를 구현한 여러 구현체 중 하나를 선택해 사용할 수 있다

* 구현체로는 하이버네이트, 이클립스링크 등이 있다 

### Hibernate

* JPA 의 구현체

* ORM의 등장 순서

  - EJB 라는 자바의 ORM 이 있었는데 성능이 안좋고, 어려운 문제로 잘 쓰이지 않았다

  - 그러던 중 하이버네이트 라는 새로운 ORM 이 오픈소스로 등장했고, 많이 사용되기 시작
 
  - 자바에서 하이버네이트의 개발자를 데려와 ORM 기술들의 표준을 개발하는데 그것이 JPA
 
  - JPA는 하이버네이트와 거의 비슷한 방식으로 개발됨
 
    - 그래도 표준인 만큼 용어나 기능면에서 더 정제되었다
 
    - 이전의 하이버네이트를 포함한 ORM 기술들은 JPA 의 표준을 따르도록 코드들이 수정됨
   
  - EJB -> 하이버네이트 -> JPA(하이버네이트와 거의 비슷한 자바에서 제공하는 ORM 표준)

### Spring Data JPA

* Spring에서 제공하는 라이브러리로 JPA를 쉽게 사용할 수 있게 도와준다

* Spring Data JPA 라이브러리를 통해 Repository 인터페이스를 사용할 수 있고, Repository 인터페이스를 구현해서 JPA를 쉽게 사용할 수 있다

### JPA 사용 이유

* dbms 벤더마다 다른 sql을 알아서 생성해주기에 벤더 독립성을 가진다

* jpa가 sql을 자동 생성해주기때문에 생산성이 향상

* 객체와 db의 패러다임 불일치를 개발자 대신 해결해준다

  - 이전에는 데이터의 변경사항을 테이블 구조에 맞는 SQL을 일일히 작성해서 반영해야 했는데 JPA 이후로는 데이터의 수정사항을 엔티티라는 객체에 반영해주면 JPA가 자동으로 객체 구조로 저장된 데이터를 테이블 구조에 맞는 SQL로 바꿔서 DB에 반영해준다
