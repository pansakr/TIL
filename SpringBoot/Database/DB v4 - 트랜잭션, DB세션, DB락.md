### 트랜잭션

* 나눌 수 없는 최소한의 작업 단위

```
1. A가 B에게 계좌이체를 할 때 A의 잔고는 감소하고, B의 잔고는 늘어나는 두 가지의 작업이 실행된다.

2. 만약 뒷 작업에 오류가 발생해 B의 잔고가 늘어나지 않았다면 A의 잔고만 감소하는 심각한 문제가 발생한다

3. 트랜잭션을 사용하면 두 작업 모두 성공해야 저장하고, 둘중 하나라도 실패하면 이전으로 돌아갈 수 있다
``` 

* 모든 작업이 성공해서 데이터베이스에 정상 반영하는 것을 커밋(Commit)이라 하고, 작업 중 하나라도 실패해서 이전으로 되돌리는 것을 롤백(Rollback)이라 한다.

### 트랜잭션 ACID 

* 원자성 - 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것처럼 모두 성공 하거나 모두 실패해야 한다.

* 일관성 - 모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야 한다. 예를 들어 데이터베이스에서 정한 무결성 제약 조건을 항상 만족해야 한다.

* 격리성 - 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리한다. 예를 들어 동시에 같은 데이터를 수정하지 못하도록 해야 한다. 격리성은 동시성과 관련된 성능 이슈로 인해 트랜잭션 격리 수준(Isolationlevel)을 선택할 수 있다.

* 지속성 - 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다. 중간에 시스템에 문제가 발생해도 데이터베이스 로그 등을 사용해서 성공한 트랜잭션 내용을 복구해야 한다.


### 트랜잭션 격리 수준

* READ UNCOMMITED(커밋되지 않은 읽기)

* READ COMMITTED(커밋된 읽기)

* REPEATABLE READ(반복 가능한 읽기)

* SERIALIZABLE(직렬화 가능)

* 위로 갈수록 동시성은 증가하지만 안정성이 나빠진다

* 일반적으로 READ COMMITTED 을 많이 사용한다 


### DB 세션

* 클라이언트와(사용자) DB가 연결되어 있는 상태

* 사용자가 데이터베이스와의 연결을 통해 데이터를 주고받는 동안 유지되는 상태

* 웹 애플리케이션 서버가 데이터베이스 서버와 커넥션을 맺을때 데이터베이스 서버 내부에 세션이 만들어지고 해당 커넥션을 통한 모든 요청은 이 세션을 통해 실행된다

* db 접근이 필요한 사용자의 요청 하나하나마다 커넥션 풀에서 커넥션을 가져와 db 세션에 만들어지고 요청 처리가 완료되면 커넥션 풀을 반납해 db 세션도 종료된다

```
1. 클라이언트의 요청

2. 애플리케이션 서버는 db 커넥션을 획득하고 데이터베이스 서버는 해당 커넥션과 연결된 db 세션 생성

3. 애플리케이션 서버가 커넥션을 통해 sql을 전달하면 연결된 데이터베이스 세션이 sql 실행

4. 세션은 트랜잭션을 시작해고, 커밋 또는 롤백을 통해 트랜잭션을 종료

5. 연결된 커넥션이 닫히지 않는다면 이후 새로운 트랜잭션을 다시 시작할 수 있다 (하나의 db 세션에서 여러 트랜잭션 처리)

6. 요청 처리가 완료되어 커넥션을 반납하거나, DBA(DB 관리자) 가 세션을 강제로 종료하면 세션 종료
```

* 커넥션 풀이 10개의 커넥션을 생성하면 세션도 10개 만들어진다


### 트랜잭션 개념

* 데이터 변경(등록, 수정, 삭제) 쿼리를 실행하고 결과를 반영하려면 커밋 명령어를 호출하고, 반영하고 싶지 않으면 롤백 명령어를 호출하면 된다

* 커밋을 실행하기 전 가진 임시로 데이터를 저장하는 것이다. 따라서 해당 트랜잭션을 시작한 세션(사용자) 에게만 변경 데이터가 보이고 다른 세션에는 변경 데이터가 보이지 않는다

* 커밋을 실행하지 않아도 저장된다면 자동 커밋 명령어가 적용되어 있는 경우이다

```
0. 사용자 A(세션 1), B(세션 2) 가 있고, DB에는 비어 있는 Member 테이블이 있다

1. A와 B가 Member 테이블 조회 시 빈 테이블 조회됨

2. A가 트랜잭션을 시작해 회원1, 2 를 Member 테이블에 추가했다. 아직 커밋은 하지 않아서 새로운 데이터는 임시 상태로 저장된다

3. A(세션 1) 는 select 를 실행해 본인이 입력한 신규 회원을 모두 조회할 수 있다

4. B(세션 2) 는 select 를 실행해도 신규 회원들을 조회할 수 없다. A(세션 1)이 커밋을 하지 않았기 때문이다

5. A(세션 1) 이 커밋을 호출해 실제 데이터베이스에 반영되고 데이터의 상태가 임시 -> 완료로 변경된다

6. 이제 다른 세션에서도 Member 테이블 조회 시 신규 회원들을 확인할 수 있다.


5-1. A(세션 1) 이 커밋 대신 롤백을 호출했다

5-2. A 가 데이터베이스에 반영한 모든 임시 데이터가 처음 상태로 복구된다

5-3. 수정하거나 삭제한 데이터도 롤백을 호출하면 모두 트랜잭션을 시작하기 직전의 상태로 복구된다

// 커밋하지 않는 데이터가 보인다면, 세션2는 데이터를 조회했을 때 신규 회원1, 2가 보일 것이다. 
// 따라서 신규 회원1, 신규 회원2가 있다고 가정하고 어떤 로직을 수행할 수 있다. 

// 그런데 세션1이 롤백을 수행하면 신규 회원1, 신규 회원2의 데이터가 사라지게 된다. 
// 따라서 데이터 정합성에 큰 문제가 발생한다.
```


### 자동 커밋

* 자동 커밋으로 설정하면 각각의 쿼리 실행 직후 자동으로 커밋을 호출한다

* 커밋이나 롤백을 직접 호출하지 않아도 되는 편리함이 있지만 쿼리를 하나하나 실행할 때 마다 자동으로 커밋이 되어버리기 때문에 트랜잭션 기능을 제대로 사용할 수 없다

* 보통 자동 커밋 모드가 기본으로 설정된 경우가 많기 때문에, 수동 커밋 모드로 설정하는 것을 트랜잭션을 시작한다고 표현할 수 있다.

```sql
set autocommit true; //자동 커밋 모드 설정
insert into member(member_id, money) values ('data1',10000); //자동 커밋
insert into member(member_id, money) values ('data2',10000); //자동 커밋
```
```sql
set autocommit false; //수동 커밋 모드 설정
insert into member(member_id, money) values ('data3',10000);
insert into member(member_id, money) values ('data4',10000);
commit; //수동 커밋
```

* 수동 커밋 모드나 자동 커밋 모드는 한번 설정하면 해당 세션에서는 계속 유지된다. 중간에
변경하는 것은 가능하다.

* 만약 오토 커밋 모드로 동작할때 출금, 입금 으로 이루어진 계좌이체 로직 실행 중 실패 시 쿼리를 하나 실행할 때마다 바로 커밋이 되기 때문에 출금만 되고 입금은 되지 않는 문제가 발생할 수 있다

### DB 락 - 변경

* 한 세션이 트랜잭션을 시작해 데이터를 수정하는 동안 커밋이나 롤백 전까지 다른 세션에서 해당 데이터를 수정할 수 없게 막는 것

```
// 세션1, 세션2가 같은 데이터를 변경하려고 동시에 요청한 상황
1. 세션 1 이 0.1초 빨리 요청 해서 먼저 트랜잭션을 시작한다

2. 세션 1은 데이터의 변경에 앞서 해당 로우의 락을 먼저 획득한다. (데이터를 수정 요청한 곳이 없으면 락은 남아있다)

3. 세션 1은 락을 획득했으므로 해당 로우에 update sql을 수행한다

4. 세션 2도 0.1초 차이로 도착해 트랜잭션을 시작한다

5. 세션 1과 같은 데이터를 변경하려 시도하고, 변경에 앞서 해당 로우의 락을 획득하려 시도한다

6. 락이 없으므로 락이 돌아올 때 까지 대기한다 (설정한 대기시간을 넘어가면 락 타임아웃 오류가 발생한다)

7. 세션 1은 커밋을 수행한다. 커밋으로 트랜잭션이 종료되었으므로 락도 반납한다

8. 락을 획득하기 위해 대기하던 세션2 가 락을 획득해 update sql을 수행한다

9. 세션 2는 커밋을 수행하고 트랜잭션이 종료되었으므로 락을 반납한다
```
```sql
SET LOCK_TIMEOUT <milliseconds> - 락 타임아웃 시간 설정
```

### DB 락 - 조회

* 보통 데이터를 조회할 때는 락을 획득하지 않고 바로 데이터를 조회할 수 있다

* 그런데 조회 시점에 락이 필요한 경우가 있다

* 예를 들면 애플리케이션 로직에서 특정 회원의 금액을 조회 후 그 금액 정보로 어떤 계산을 수행하는데 이 계산이 중요한 계산이라 작업이 완료되기 전까지 다른곳에서 변경하면 안되는 경우. 이럴 때 조회 시점에 락을 획득하면 된다
