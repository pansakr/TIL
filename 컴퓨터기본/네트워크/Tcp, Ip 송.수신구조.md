### 송신측

* 서버에서 1.5mb의 데이터를 보낼때 MTU보다 크다는 문제가 있다.

* 이때는 보낼 데이터를 스트림 단위로 잘라서 프로세스의 버퍼에 담고 이것을 소켓의 입출력 버퍼에 복사한다.

* 복사된 데이터는 커널모드의 tcp로 넘어가는데 이 지점에서 데이터의 분해가 일어난다.

* 분해된 데이터의 각 조각이 L4의 데이터 단위인 세그먼트가 되고, 일련번호가 붙는다.

* 세그먼트화된 데이터들이 ip계층으로 내려가 패킷으로 캡슐화 된다. (헤더, 페이로드로 이루어진 세그먼트의 앞에 패킷의 헤더가 붙는다.)

* 패킷이 L2계층으로 내려가 Frame로 캡슐화(패킷에 Frame헤더가 붙는다) 되고, dvice driver -> Nic를 거쳐 전송된다.

* 전송 도중 Frame은 바뀔 수 있지만 패킷은 바뀌지 않는다.


### 수신측

* 수신한 Frame이 Nic -> Driver -> Ip -> TCP 로 올라가며 Frame -> Packet -> Segment 순서로 역캡슐화되어 최종적으로 Segment가 남는다.

* Segment는 유저 모드 소켓의 입출력 버퍼에 분해됬을때의 일련번호순서로 담긴다.

* 입출력 버퍼에 담긴 세그먼트들이 프로세스 버퍼에 담긴다.

* 소켓의 입출력 버퍼에는 수신받은 세그먼트들이 계속해서 쌓이고, 프로세스 버퍼는 쌓인 데이터들을 계속 가져온다.

* 수신측의 tcp계층에서 데이터를 받으며 일정 주기마다 받은 데이터의 일련번호와 소켓 입출력 버퍼의 여유공간(Window Size)을 act로 송신측에게 보낸다.

* 송신측에서는 데이터를 일정량 보내면 잠시 대기하다가 act를 받고 일련번호로 데이터를 잘 받았는지, 여유 공간이 있는지 확인후 데이터 송신을 재개하고 모든 데이터를 보낼 때까지 반복된다.

* 데이터를 잘 받았더라도 여유공간이 없으면 보내지 않는다.


### 네트워크 장애 유형

* 세그먼트가 유실된 경우

* 세그먼트의 순서가 바뀌어서 올때(Out of Order)

* 수신측이 act를 늦게 보내서 송신측에서 보냈던 데이터를 다시 보내고, 수신측은 이미 받았던 데이터가 또 오니 그에대한 act를 또 송신측에 보내 act가 중복될때

* 송신측이 받은 act에 수신측의 여유공간이 없다고 되어있을때(Zero of Window)
