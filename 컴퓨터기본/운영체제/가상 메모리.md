### 가상 메모리

* 메모리 관리 기법의 하나로 프로세스에 실제 메모리 주소가 아닌 가상의 메모리 주소를 주는 방식

* 물리 메모리보다 큰 프로세스를 수행하기 위해 사용한다.

* 물리 메모리는 RAM, 가상 메모리의 실제 공간은 하드디스크다.

* 프로세스를 실행할 때 현재 실행에 필요한 부분만 메모리에 올린다.

* 실행될 가능성이 낮은 오류 처리코드나 과도하게 크게 선언된 데이터 영역등은 하드디스크에 적재한다.

* 프로세스는 가상메모리 공간도 물리메모리 공간으로 인식한다.

* 이후 가상메모리에 적재한 부분이 실제로 필요하다면 운영체제가 물리메모리 공간과 변경해준다. 디스크 -> 메모리는 swap-in, 반대는 swap-out이다.

* 메모리에는 고유의 물리 주소가 있고 운영체제가 사용하는 부분을 제외한 다음 주소부터 논리주소 0으로 시작, 이후 가상메모리까지 모든 주소를 붙인다.

* 가상메모리에 적재한 프로세스 일부분을 물리메모리에 옮길 경우 논리주소를 물리주소에 연결한다. 이를 매핑이라 한다. 

### 페이징 

* 가상메모리를 일정 크기로 잘라놓고 그 크기에 프로세스를 맞게 자르는 방법

* 가상메모리를 쪼개서 페이지 번호, 물리메모리도 페이지와 같은 크기로 쪼개서 프레임으로 만든다.

* 페이지와 프레임을 매핑한 페이지 테이블을 만든다. 여기에는 페이지번호가 붙은 공간에 프레임 번호가 연결되어있다.

* 프로세스는 메모리를 할당받을때 할당받은 물리 메모리의 프레임과 페이지가 매핑된 페이지 테이블을 한개씩 받는다.

*세그먼테이션 - 프로세스를 자르고 거기에 메모리 크기를 맞추는 방법


### 프로세스가 메모리를 나눠서 적재하고 가져오는 방법

* 프로세스에 메모리를 할당할때 프로세스를 A,B,C로 균등하게 나누고 당장 실행에 필요한 A는 물리 메모리에 적재하고 나머지는 가상 메모리에 담는다

* 가상 메모리에 담은 프로세스가 물리 메모리의 프레임과 가상 메모리의 페이지가 매핑된 페이지 테이블에 기록되고 해당 페이지 테이블을 프로세스가 가진다.

* 이후 B가 실행에 필요할 시 페이지 테이블을 참고해 B가 적재된 페이지와 연결된 프레임을 참조해 해당 물리 메모리의 주소에 B를 적재해 실행한다. // 수정필요

* 만약 실행도중 A가 필요없어서 가상 메모리에 옮길 때는 마찬가지로 페이지 테이블에 A가 적재된 프레임과 연결된 페이지를 참조해 해당 가상 메모리의 공간에 적재한다.  // 수정필요


### mmu(Memory Management Unit)

* 가상 메모리주소를 실제 메모리 주소로 반환해주는 칩

* cpu에서 어떤 정보가 필요할때 가상 주소를 가지고 페이지 테이블을 통해 메모리의 물리 주소에 접근한다.

* 그런데 cpu 내부의 tbl라는 캐시가 자주 사용하는 페이지 테이블을 가지고 있어서 cpu는 페이지 테이블을 거치지 
않고 메모리의 주소에 바로 접근이 가능하다.

* tbl캐시는 mmu안에 있는것으로 즉 mmu가 가상 메모리 주소를 실제 메모리 주소로 변환해준다.
