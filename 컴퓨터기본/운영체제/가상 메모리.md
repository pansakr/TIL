### 가상 메모리

* 메모리 관리 기법의 하나로 프로세스에 실제 메모리 주소가 아닌 가상의 메모리 주소를 주는 방식

* 프로세스들이 생성되면 각각의 프로세스는 독립된 가상 공간을 할당받는다.

* 물리 메모리보다 큰 프로세스를 수행하기 위해 사용한다.

* 물리 메모리는 RAM, 가상 메모리의 실제 공간은 하드디스크다.
```
// 가상 공간은 가상 주소를 가지는데 A프로세스에서 1이라는주소를 가질 수 있고, 동시에 B에서도 1이라는 주소를 가질 수 있다.

// 이 두 프로세스에 1이라는 주소에 접근하라는 명령을 내릴 경우 CPU는 가상 주소를 가지고 프로세스마다 가지고 있는 페이지 테이블을 참조한다.

// 페이지 테이블은 가상 주소와 실제 주소를 연결시켜주는 테이블이다.

// A프로세스의 페이지 테이블은 1 - 0X1000으로 매핑되어있고 B는 1 - 0X5000 으로 매핑되어있으면 가상 주소는 둘다 1로 같지만 매핑되어있는 실제 메모리 주소는 0X1000, 0X5000으로 다른 것이다.
```


### 물리주소, 가상주소, 상대주소

* 메모리의 물리적인 실제 주소 - 물리주소

* 가상 메모리의 주소 - 가상주소

* 메모리의 주소가 0~999까지 있고 운영체제가 0~360 까지 사용했다고 할때 운영체제의 메모리 영역을 제외한 사용자가 사용할 수 있는 메모리의 첫 부분을 0이라고 놓고 '0부터 40만큼 떨어진 위치' 가 상대주소다


### 메모리 오버레이

* 프로세스의 일부분만 잘라서 메모리에 적재하는것


### 스왑 영역

* 하드디스크에 프로세스가 저장되는 공간을 스왑 영역이라 한다.

* 디스크 -> 메모리는 swap-in, 반대는 swap-out이다.

* 스왑 인,아웃 -> 페이지 인,아웃이라고도 한다.


### 메모리 분할 방식 - 가변 분할 방식(세그먼트)

<img src="https://github.com/pansakr/TIL/assets/118809108/1fbc5893-18b8-4e53-9937-c8208721bf1a">

* 저마다 다른 크기의 프로세스를 메모리에 이어서 붙이는 방법이다. 

* 프로세스마다 메모리에 나뉘지 않고 온전히 들어간다.

* 하지만 일부 프로세스들이 종료되어 메모리가 비워지고 이후 다른 프로세스를 실행하려 하는데 그 크기가 비워진 프로세스 공간들보다 크다면 사용할 수 없다. 

* 이렇게 사용할수 없는 메모리 공간들을 외부 단편화 라고 하고 조각 모음을 통해 합쳐줘야 한다.


### 메모리 분할 방식 - 고정 분할 방식(페이징)

* 프로세스를 균일하게 잘라 붙이는 방식이다. 

* 프로세스가 30kb이고 20kb단위로 자른다면 첫번째 조각은 알맞게 들어가고 두번째 조각은 10kb가 남는 상태로 들어간다. 

* 남는 부분은 사용하지 못하는 부분이고 내부 단편화라고 한다. 

* 그리고 하나의 프로세스를 여러 조각으로 잘라 넣어도 가변 분할방식처럼 이어서 들어가지 않고 다른 프로세스와 섞여 들어갈 수 있다.

* os는 가변, 고정 두 방법을 섞어서 쓴다.

* 가상 메모리는 페이지, 물리 메모리는 프레임 단위로 일정 크기로 나눈다.(WINDOW의 경우 각 단위당 크기는4KB)

* 기준 위치를 잡고 기준으로부터 얼마나 떨어져있는가를 상대주소(Distance)이라고 한다.

```
// 예를 들어 프로세스가 할당받은 가상 메모리가 0~59까지의 길이라 가정했을때
// 0 ~ 9, 10 ~ 19, 20 ~ 29, 30 ~ 39, 40 ~ 49, 50 ~ 59 까지 자른것이 페이지다.
// 그리고 페이지별로 세부적인 위치가 있는데 15번이라면 1페이지고 그 위치를 잡을때 10을 기준으로 잡고
// 10부터 얼마나 떨어져있는가 -> 5만큼 떨어짐 
// 그러면 전체 주소는 1페이지 와 연결된 프레임을 찾고 그 프레임에서 5가 세부 주소이다. 
```

### MMU(Memory Management Unit)

* 가상 메모리주소를 실제 메모리 주소로 반환해주는 칩

* cpu에서 어떤 정보가 필요할때 가상 주소를 가지고 페이지 테이블을 통해 메모리의 물리 주소에 접근한다.

* 이때 mmu가 페이지 테이블을 참조해 가상주소를 물리주소로 변환해 주고 cpu는 페이지 테이블을 거치지 않고 메모리의 주소에 바로 접근이 가능하다.


### 페이지 테이블

* 페이지와 프레임을 연결해 가상주소와 실제 주소를 연결해주고 페이지의 접근 권한을 권한비트로 저장해놓은 테이블

* 권한비트의 권한은 읽기 / 쓰기 / 실행 이다.

* 램의 1바이트단위의 모든 주소를 매핑해 변환해주려면 작업 부하가 높아지므로, 램과 가상 주소를 여러 부분으로 나누어 각 부분을 주소처럼 사용한다.

* cpu가 프로세스의 가상 주소를 가지고 요청을 하면 mmu가 매핑 테이블을 보고 물리 주소로 바꿔준다.  

* 이때 mmu는 가상 주소에 대한 프레임의 접근 권한을 보고 유효할 찾아주고 그렇지 않으면 페이지 폴트를 일으킨다.

* cpu는 변환된 물리 주소를 받아 메모리에 접근한다.

* 하지만 mmu가 가진 매핑 테이블에 가상 주소(페이지)에 매핑된 물리주소정보(세그먼트, 프레임)가 없다면 페이지 폴트, 세그멘테이션 폴트가 발생한다.

* 페에지 폴트가 발생할 경우 os가 가상 메모리에서 해당 주소를 메모리에 적재해준다.


### CPU가 가상주소로 물리 주소를 찾는 순서

* 프로그램 A,B가 실행되어 각각 스왑 영역에 가상 메모리 공간을 할당받는다.

* A와 B는 각각 0~3000 까지의 공간을 받아서 4KB씩 0~9, 10~19, 20~29.. 의 0, 1, 2.. 페이지로 나눈다.

* 물리 메모리도 4KB씩 0,1,2,3,4,5 프레임으로 나눈다.

* A,B는 당장 실행에 필요한 0번 페이지를 물리 메모리의 2번 프레임에 적재하고 각각 페이지 테이블에 기록한다.

* 페이지 테이블에는 권한비트, 0번 페이지 - 2번 프레임, 나머지 페이지 - 스왑 이렇게 기록된다.

* A프로세스 실행시 CPU가 실행에 필요한 A프로세스의 가상 주소 0번을 가지고 메모리에 요청한다.

* MMU가 먼저 요청을 받아 A프로세스의 페이지 테이블을 참조해 접근권한이 유효한지 확인하고, 0번 가상주소가 매핑된 2번프레임을 물리 주소로 변환해준다.

* CPU는 받은 물리 주소와 Distance로 메모리에 접근해 필요한 데이터를 받아온다.
