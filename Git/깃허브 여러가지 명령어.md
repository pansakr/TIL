### 깃 커밋 원리

* 초기설정 유저네임, 이메일이 설정되있지 않다면 먼저 설정해준다. git 설치후 1회만 하면 된다.

* git init으로 작업 영역을 지정한다.

* git status로 변경된 파일을 확인한다. 

* git add . 으로 모든 변경 내역의 인덱스를(스냅샷) 남긴다. (현재 상태의 트리 생성됨)

* git commit -m "커밋 메시지" 으로 저장하면 스냅샷을 해시해 .git폴더 내부에 저장하고 커밋 메시지가 브랜치에 기록된다.

* 그리고 head가 해시되어 저장된 파일을 참조하며 기록된 파일을 가리킨다.

* 새로운 파일 추가 시 인덱스에 해당 트리가 새로 만들어지고 해시되어 .git폴더에 저장되고 브랜치에 커밋 메시지가 기록된다.

* 생성된 새로운 트리는 이전의 트리 구조를 포함하고 있다.

* 그리고 head가 새로 생성된 해시 파일을 참조하고 브랜치에 두번째 기록된 파일을 가리킨다.

* 새로운 변경사항이 적용되면 head는 늘 마지막 스냅샷이 해시된 파일을 참조하고 동시에 브랜치의 마지막 커밋 기록을 가리키고 있다.

*스냅샷 - 특정 시간의 데이터 저장 장치의 상태를 별도의 파일이나 이미지로 저장하는 기술


### 깃의 3가지 작업 영역

* working directory(작업 공간) - 파일을 생성하고 수정하는 폴더

* repository(저장소) - git에서 작업한 이력들을 저장하는 저장소. .git 폴더를 의미한다.

* staging area(임시 저장 공간) - git add .한 파일들이 존재하는 영역. 커밋시 staging area에 있는 파일들만 반영된다.

* working directory에서 작업후 git add 해서 staging area에 넘기고 commit시 staging are에 있던 파일들이 repository에 저장된다.




### 깃 리셋 git resset --옵션

* soft, mixed, hard가 있다.

* hard - repository, staging area, working directory의 파일 전부다 삭제한다. 이전 상태로 돌아가거나 복구할때 사용한다.

* mixed - staging area, working directory 까지 삭제한다. 작업 영역의 내용 변경시 사용. 그러나 한번더 커밋해 변경하는 방법을 자주 사용하기에 거의 사용하지 않는다.

* soft - repository에 저장된 부분만 삭제한다.(헤더가 가리키는 위치가 이전으로 바뀐다.) 커밋로그 변경시 사용


### 모든 커밋 기록 확인 git reflog

* 이전 버전으로 복구하려할때 커밋 기록이 남아있지 않을 시 사용한다.

* git reflog하면 한번이라도 커밋했다면 그 기록을 모두 출력해준다. 

* 원하는 버전의 해시값을 찾아서 git reset 명령어로 복구한다.


### 최종 커밋 수정 git commit --amend -m "커밋 메시지"

* 커밋 기록이 하나밖에 없다면 head가 가리킬 이전 버전이 없어서 reset 명령어를 사용할 수 없다.

* 이때 --amend 를 사용해 커밋 메시지를 수정할 수 있다.


### merge

* 3way merge는 형상이 다를때, fast forward merge는 형상이 같을 때 사용한다.


### 브랜치 포인터

* 해당 브랜치가 가리키고 있는 지점


### Head

* 지금 작업하는 브랜치를 가리키는 포인터

* 헤더가 있는 브랜치로 작업을 하게 된다.



### 브랜치 생성, 체크아웃

* 브랜치 생성 - git branch 브랜치이름

* 브랜치 변경 - git checkout 브랜치이름. 여러 브랜치가 있을때 헤더를 변경하는 명령어이다.

* 생성과 변경 동시 - git chechout -b 브랜치이름



### fast forward merge

* A 파일 커밋시 저장소에 저장되고 메인 브랜치 포인터가 마지막 커밋 기록 A를 가리킨다.

* 새로운 서브 브랜치 생성 시 서브 브랜치 포인터도 마지막 커밋 기록 A를 가리킨다.

* CHECKOUT 명령어로 헤더를 서브 브랜치로 변경 후 B파일을 커밋하면 헤더와 서브 브랜치 포인터는 B를 가리킨다.

* 메인 브랜치 포인터는 여전히 A를 가리키고 있다.

* CHECKOUT로 헤더를 메인 브랜치로 변경 시 서브 브랜치로 커밋한 B파일은 보이지 않는다. A로 커밋한 A파일만 보인다.

* 현재 메인 브랜치는 A만 보이고 서브 브랜치는 A와 B 모두 보이는 상태이다.

* 즉 자신이 작업한 영역만 볼 수 있다.

* 이때 git merge 서브 브랜치 명령어로 merge를 하게되면 메인 브랜치 포인터가 B를 가리리케 되어 두 브랜치가 하나로 합쳐진다.

* merge log가 남지 않는다.


### 3way merge

* 메인 브랜치에서 A파일 커밋시 메인 브랜치 포인터가 A를 가리킨다.

* 서브 브랜치 생성 시 A를 가리키고 CHECKOUT로 헤더를 변경해서 B커밋시 서브 브랜치 포인터가 B를 가리킨다.

* 다시 헤더를 메인으로 바꾸고 C커밋시 분기점이 생기고 메인 브랜치 포인터는 C를 가리킨다

* 메인이 C커밋 전까지는 같은 조상인 A라인에 있었지만 C커밋이후 메인은 C라는 다른 형상을 포함하게 되어 분기점이 생겼다.

* 이 상태에서 fast forward merge하면 C를 가리키던 메인 브랜치 포인터가 B로 이동하기에 C가 사라져 이 방법은 사용할 수 없다.

* 이 상태에서 올바른 merge는 공통 조상인 A와 분기점인 B, C 모두 적용되야 해서 3way merge라고 한다.

* main에 헤더가 있는 상태에서 git merge 서브브랜치 하면 vi편집기 화면으로 넘어가고 :를 입력해 명령어 커서를 만들고 wq로 저장후 빠져나가기를 한다.

* git log를 확인해보면 최상위에 merge branch 서브브랜치 merge했다는 표시가 적혀있고 밑으로 B와 C가 합쳐져 있는걸 볼 수 있다.


### merge 충돌

* 3way merge에서 같은 파일을 합칠시 두 파일의 내용이 다르다면 conflict 에러가 생긴다.

* 두개의 분기중 하나를 선택하거나 두개를 합쳐서 새로운 분기를 만들어 병합한다.

* 보통은 사람마다 다른 작업을 부여해서 파일이 분기가 겹치지 않게 한다.


### 로그 정리 git rebase

* 1 ~ 4 번 로그가 있고 2 ~ 4을 압축해서 하나의 로그로 만든다면 2번을 선택해 3, 4번을 2번으로 땡겨와 압축해야 한다.

* 깃 용어로 정리한다면 2번을 pick 해서 3, 4번을 squash한다. 가 된다.

* 반대로 4번을 선택해 2, 3 번을 땡겨와 압축한다면 중간의 2, 3번 로그가 비게 되므로 사용하면 안된다.

* git rebase -i head~3(헤드가 가리키고 있는 로그포함 3개의 로그) 을 사용해 vi편집기 화면으로 넘어간다

* i를 눌러 insert모드로 들어가고 방향키를 사용해 압축할 커밋 기록을 pick에서 s로 바꿔준다.

* s가 pick으로 압축된다. esc를 눌러 insert모드에서 나오고 :을 눌러 명령어 창을 열고 wq로 빠져나온다.

* 이후 화면에서 압축한 로그의 커밋 메시지를 지우고 pick한 로그의 커밋메시지를 원하는 대로 수정 후 esc -> : -> wq로 빠져나온다.

* 로그를 확인해보면 2 ~ 4가 2 하나로 압축되어 1, 2 만 남아있어 깔끔해졋다.

*squash - 찌그러트리다, 압축하다.


### 깃허브로 올리기 git push origin main

* git remote add origin https주소 하면 내 로컬 저장소가 깃허브의 원격 저장소와 연결된다.

* git remote -v나 git ls-remote 하면 연결된 원격 저장소를 알 수 있다.

* 원격 저장소 연결을 잘못 했다면 git remote rm origin 을 사용해 해제할 수 있다.

* git push origin main 오리진의 메인 브랜치로 푸시 한다.

* push는 업로드 + merge 가 합쳐진 키워드이다.

*origin - 깃허브의 원격 저장소 이름


### 깃허브의 파일을 다운받기 git pull origin main

* git pull origin main으로 원격 저장소의 파일을 로컬 저장소로 다운받는다.

* pull은 다운로드 + merge가 합쳐진 키워드이다.


### 세개의 명령어를 합친 git clone

* git init, git remote ~, git pull 명렁어를 합친게 git clone이다.

* 다운받을 폴더에 가서 git clone 주소 하면 .git 폴더를 만들고 저장소와 연결하고 파일을 다운받는것까지 한번에 완료된다.

* 처음 프로젝트를 세팅할때 사용한다.


### 여러 장소에서 작업할 때 git 사용법

* 회사에서 '프로젝트 설정완료', 파일을 만들고 push했다.

* 집에서 이어서 작업하려고 하는데 첫 세팅이니까 clone으로 원격 저장소의 파일을 다운받고 추가 작업하진 않았다.

* 이후 다시 회사에서 '회원가입' 파일을 만들고 push한다.

* 현재 원격 저장소에는 '프로젝트 설정완료', '회원가입' 이 있고, 집의 로컬 폴더에는 '프로젝트 설정완료'가 있다.

* 집에서 이어서 작업하기 위해 원격 저장소에서 다운받아야 하는데 동기화를 먼저 해줘야 한다.

* git pull origin main으로 다운로드 + 병합 해준다. 로그는 원격 저장소와 같은 2개가 있다.

* '로그인' 파일을 만들고 push한다.

* 이번엔 제주도에서 작업하는데 마찬가지로 해당 컴퓨터에서의 첫 작업이니까 clone으로 파일을 다운받는다.

* '글쓰기' 파일을 작업하는데 50프로만 완성하고 topic 브랜치를 만들어 push한다.

* 원격 저장소에 topic브랜치가 만들어지고 '글쓰기'가 저장된다.

* 원격 저장소의 topic 브랜치엔 '글쓰기' 까지 4개, main브랜치에는 '로그인'까지 3개의 파일이 있다.

* 회사로 돌아와서 이어 작업하기 위해 git pull origin main으로 원격 저장소의 main 브랜치의 3개의 파일과 '회원가입' 까지 2개의 파일만 있는 회사 로컬 저장소를 동기화한다.

* 그런데 50프로 완료한 '글쓰기' 파일은 topic브랜치에 있어서 git fetch origin로 모든 브랜치를 다운받고  git checkout -b topic origin/topic로 merge할 원격 브랜치와 같은 로컬 브랜치를 만들고 병합한다.

* 이제 동기화가 완료되었고 '글쓰기' 파일을 완료해 commit한다.

* 현재 회사 로컬 main브랜치는 파일 2개, topic브랜치는 완료된 글쓰기까지 5개다.

* 현 시점에서 topic 로그를 보면 '프로젝트 설정완료', '회원가입', '로그인', '글쓰기 50프로', '글쓰기 100프로' 5개다.

* 이제 main과 topic을 병합해 주어야 하는데 topic 브랜치의 '글쓰기 50프로', '글쓰기 100프로' 파일은 그대로 두고 둘의 로그만 하나로 합치고 싶다.

* main브랜치에서 '프로젝트 설정완료', '회원가입', '로그인' 을 clone해서 topic 생성후 '글쓰기 50프로', '글쓰기 100프로'를 작성했으니 main과 달라진 부분은 마지막 두 커밋이고 압축될 커밋고 마지막 두 커밋이다.

* git merge --squash topic으로 main과 병합할 topic 브랜치의 모든 커밋(main clone후 달라진 커밋들)을 하나의 커밋으로 압축해서 병합한다.

* 이때 새로 merge한 파일들은 git add . 까지만 한 상태로 병합되기 때문에 git commit -m 을 한번 더 해줘서 저장해주고 압축되어 병합된 topic브랜치의 커밋 메시지를 새로 작성해준다.

* 파일들은 그대로 병합되고 커밋 메시지만 하나로 압축되어 새로 작성하는 것이다.

* push 해주면 원격 저장소는 커밋 기록이 깔끔하게 남는다.
