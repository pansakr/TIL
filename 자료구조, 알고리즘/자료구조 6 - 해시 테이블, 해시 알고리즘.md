### 해시 테이블

* 해시값을 사용하여 데이터를 저장하고 검색하는 자료구조

    - 구성 요소

        - 키 : 데이터를 식별하는 값

        - 값 : 저장되는 실제 데이터

        - 버킷 : 해시 테이블에서 데이터를 저장하는 공간 단위

            - 해시 테이블의 크기가 10이면 버킷 개수도 10개이다

            - 해시값을 해시 테이블의 크기(버킷 개수)로 나눈 나머지가 해시값이 저장될 버킷 인덱스다

            - ex) 해시값이 17, 버킷이 10 개라면 버킷 인덱스는 17 % 10 = 7 이다 

    - 해시 함수 : 입력 데이터를 특정 규칙(알고리즘)을 통해 고정된 크기의 정수 값으로 변환하는 함수

    - 해시값 : 해시 함수의 결과로 나온 고정 크기의 정수 값

        - 이 값은 데이터의 고유한 서명(signature) 역할을 한다

        - 해시값은 데이터가 해시 테이블 내에서 어디에 저장될지를 결정 (주소 역할)

### 해시법

* 데이터를 특정한 규칙에 따라 고유한 값으로 매핑하는 알고리즘

* 해시 테이블 자료구조에서 사용하며 검색, 추가, 삭제를 효율적으로 수행할 수 있다

* 예시 : 배열 a를 해시 테이블로 변환

    - a 배열 각각의 요소를(키) 해시 함수에 넣어 해시값 생성

    - 해시 테이블의 버킷 인덱스 계산

    - 계산된 버킷 인덱스에 해시값의 원본 데이터 저장

    ```java
    // 배열 a. 원본 데이터
    a = {10, 20, 30}

    // 배열 a의 각 요소(키)를 해시 함수에 넣어 해시값 계산
    // hash(10) -> 25, hash(20) -> 32, hash(30) -> 41
    b = {25, 32, 41}

    // 해시 테이블. 0은 값이 없을 때 설정되는 기본값
    // 해시값을 배열 크기(버킷 수)로 나눈 나머지를 계산해 해시값에 해당하는 원본 데이터가 저장될 인덱스 결정
    c = {0, 30, 20, 0, 0, 10}
    ```

    - a의 10을 c의 c[5] 위치에 저장하는 이유는 10의 해시값은 25 이고, 버킷 인덱스 계산 시 25에 대한 버킷 인덱스는 5가 나온다
            
    - 그래서 c[5]에 해시값 25의 원본 데이터 10을 저장한다

* 해시법을 사용해 배열에 데이터 추가

    - 해시법 미사용 예시

        ```java
        // 배열 a의 크기는 10. 배열 a에 25 추가
        a = {10, 20, 30, 40, 0, 0, 0, 0, 0, 0}

        // 추가 후
        a = {10, 20, 25, 30, 40, 0, 0, 0, 0, 0, 0}

        1. 삽입할 위치를(a[1]와 a[2] 사이) 이진 검색으로 조사

        2. a[2] 이후의(a[2] 포함) 모든 요소를 하나씩 뒤로 이동

        3. a[2]에 25 대입
        ```

    - 해시법 사용 예시

        ```java
        // 배열 a의 크기는 10
        a = {10, 20, 30, 40, 0, 0, 0, 0, 0, 0}

        // 해시값
        b = {25, 32, 41, 49}

        // 해시 테이블. 해시값으로 버킷 인덱스를 계산해 원본 데이터를 해당 위치에 삽입
        c = {0, 30, 20, 0, 0, 10, 0, 0, 0, 0, 40, 0}

        // 해시 테이블에 50 추가
        // 버킷 계산시 50이 들어갈 인덱스는 7
        // 50의 해시값 : 57. 버킷 계산 : 57 % 10 = 7
        c = {0, 30, 20, 0, 0, 10, 0, 50, 0, 0, 40, 0}
        ```

* 충돌

    - 동일한 버킷에 데이터가 저장되는 것

    - 해시값이 동일하거나, 해시값을 나눈 나머지가 같으면 발생한다

    - 충돌 대처

        - 체인법

            - 해시값이 같은 데이터를 연결 리스트, 트리 배열 등으로 만들어 관리

            - 연결 리스트의 경우 : 버킷은 연결 리스트의 첫번째 노드의 참조를 가지고 있다

                - 11, 12 의 해시값이 모두 5이고, 5에 대한 버킷은 1 이라고 가정

                - 버킷 인덱스 1에 11, 12 의 두 데이터가 저장되야 해서 충돌이 발생한 상황

                - 11, 12를 연결 리스트로 만들고 연결 리스트의 첫번째 노드에 대한 참조(11) 를 버킷 인덱스 1에 저장 

        - 오픈 주소법

            - 충돌 시 해시 함수를 다시 수행해 비어 있는 버킷을 찾아내 저장하는 방법

            - 다시 수행하는 해시 함수의 종류는 자유롭게 결정할 수 있다

            - 해시 함수를 다시 수행해도 충돌이 나면 비어있는 버킷을 찾을때 까지 해시 함수를 반복해서 수행한다

* 성능

    - 충돌이 전혀 발생하지 않는다면 해시 함수로 인덱스를 구하는 것만으로 검색, 추가, 삭제가 완료되므로 시간 복잡도는 어느 것이나 O(1) 이 된다

    - 해시값이 동일한 키들이 같은 버킷에 몰리면 해시 테이블에서 충돌이 발생하고, 충돌 발생 시 시간 복잡도는 O(n)

    - 해시 테이블을 크게 하면 충돌 발생을 억제할 수 있지만, 메모리를 많이 차지하게 된다

    - 충돌을 피하려면 해시 함수는 해시 테이블 용량 이하의 정수를 한쪽으로(같은 버킷) 치우치지 않도록 고르게 만들어 내야 한다
