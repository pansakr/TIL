### 자료구조

* 데이터를 저장, 관리하는 방법

* 자료에 효율적으로 접근하고 수정할 수 있도록 저장하고 관리하는 방법에 관한 이론

* 선형 자료구조와 비선형 자료구조로 이루어져 있다

    - 선형 자료구조

        - 자료를 구성하는 원소들을 하나씩 순차적으로 나열시킨 형태

        - 자료들간의 앞, 뒤 관계가 1:1 의 관계이다

        - 배열, 리스트, 스택 큐 등

    - 비선형 자료구조

        - 하나의 자료 뒤에 여러개의 자료가 존재할 수 있는 형태

        - 자료들간의 앞, 뒤 관계가 1:n 또는 n:n의 관계이다

        - 트리, 그래프 등
     
* 추상 데이터 타입(ADT - Abstract Date Type)

    - 데이터를 저장하고 관리하는 방식과 동작 원칙(연산)에 대한 정의만 제공하고, 구현 방식은 구체적으로 지정하지 않은 것

    - 어떤 데이터를 어떻게 저장하고, 어떤 연산을 수행해야 하는지에 대한 개념적 정의

        - 인터페이스를 통해 데이터와 상호작용 하는 방식을 설명하며, 리스트, 큐, 스택, 맵 등이 해당된다

    - 이러한 ADT 들을 구현하는 방법은 다양하다

        - 리스트는 배열로(Array) 구현할 수도 있고, 연결 리스트로(Linked List) 구현할 수도 있다

### 알고리즘

* 문제를 해결하기 위한 절차

    - 문제 해결을 위해 입력을 받아 원하는 출력을 만들어 내는 과정을 기술한 것

    - 주어진 값 중 최소/최대/중앙 값을 구하는 간단한 것도 알고리즘에 포함된다 

* 자동차 부품(자료구조) -> 자동차 조립 방법(자료구조 + 알고리즘) -> 자동차 조립(프로그래밍 언어)

* 같은 알고리즘이라도 어떤 자료구조를 사용하느냐에 따라 성능이 달라질 수 있다

    - 자료구조마다 데이터 접근 방식과 속성이 다르기 때문

* 알고리즘 표기법

    - 알고리즘을 명확하고 간결하게 표현하기 위한 방식

    - 자연어를 이용한 서술적 표현

        - 사람이 쓰는 언어로(한국어, 영어 등) 표현하는 방법

        - 사람에 따라 일관성이나 명확성을 유지하기 어렵다

    - 순서도를 이용한 도식화(Flowchart)

        - 여러 도형을 사용해 각 단계를 나타내고, 연결선으로 알고리즘의 흐름을 시각적으로 표현

        - 흐름을 쉽게 파악할 수 있지만, 복잡한 알고리즘을 표현하는 데는 한계가 있다

    - 프로그래밍 언어를 이용한 구체화

        - 프로그래밍 언어를 사용해 표현하는 방법

        - 알고리즘 자체가 구체화되므로 추가로 구체화할 필요가 없다

        - 그러나 특정한 프로그래밍 언어로 작성하기 때문에 해당 언어를 모르면 이해하기 어렵고, 다른 프로그래밍 언어로 개발하는 경우에는 변환해야 하므로 범용성이 떨어진다

    - 가상코드를 이용한 추상화

        - 특정 프로그래밍 언어는 아니지만 프로그래밍 언어의 형태를 갖춘 가상코드로 표현하는 방법

        - 가상코드는 프로그래밍 언어가 아니므로 직접 실행할 순 없지만, 일반적인 프로그래밍 언어와 형태가 유사해 원하는 프로그래밍 언어로 구체화하기 쉽다

    - 수학적 표기방법

        - 수학적인 함수와 식으로 표현

        - 알고리즘의 시간 복잡도나 정확성을 분석할 때 사용

        - 점근 표기법
        
            - 알고리즘의 성능(실행 시간이나 메모리 사용량)이 입력 크기(n) 에 따라 어떻게 변화하는지 표현하는 방법
        
            - 주로 빅오를 중심으로 사용되며, 세타와 오메가는 상황에 따라 사용됨
        
            - 빅오 
            
                - 알고리즘의 상한을 나타내며 최악의 시간 복잡도를 설명
        
                - 입력 크기가 커질 때 알고리즘의 최대 실행 시간이 얼마인지 설명
             
                    - O(1): 입력 크기와 상관없이 일정한 시간이 걸리는 알고리즘 (상수 시간)
                  
                    - O(n): 입력 크기에 비례하는 시간이 걸리는 알고리즘 (선형 시간)
                    
                    - O(n^2): 입력 크기의 제곱에 비례하는 시간이 걸리는 알고리즘 (이차 시간)
                    
                    - O(log n): 로그 시간 복잡도를 가진 알고리즘 (로그 시간)
                 
                 - 최악의 경우
             
                     - 그러나 알고리즘이 항상 최악의 경우로 실행되는 것은 아니기 때문에, 실제로는 빅오 표기법 보다 더 빠르게 실행될 수도 있다
        
            - 오메가
            
                - 알고리즘의 하한을 나타내며 최선의 경우 시간 복잡도를 설명
        
                - 입력 크기가 커질 때 알고리즘의 최소 실행 시간이 얼마인지 설명
        
                - 최선의 경우
        
            - 세타
            
                - 알고리즘의 상한과 하한이 동일한 시간 복잡도를 가짐을 설명
        
                - 알고리즘의 시간 복잡도가 상한과 하한이 동일한 값을 가질 때 사용
        
        
        - 하나의 알고리즘에 대해 빅오, 오메가, 세타 모두를 사용할 수 있다
        
            - 버블 정렬 예시
        
                - 빅오 표기법 : 최악의 경우 표기. O(n^2)
        
                - 오메가 표기법 : 최선의 경우 표기. Ω(n)
        
                - 세타 표기법 : 최선과 최악이 동일한 시간 복잡도를 가질 때 표기. Θ(n^2)

* 복잡도

    - 알고리즘의 성능을 객관적으로 평가하는 기준

    - 시간/공간 복잡도의 두 기준이 있다

    - 시간 복잡도

        - 실행에 필요한 시간을 평가한 것

    - 공간 복잡도

        - 기억 영역과 파일 공간이 얼마나 필요한가를 평가한 것
