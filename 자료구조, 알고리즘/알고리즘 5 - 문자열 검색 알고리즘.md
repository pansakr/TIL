### 문자열 검색

* 어떤 문자열 안에 특정 문자열이 들어있는지 조사하고, 들어 있다면 그 위치를 찾는 것

    - ex) 문자열 "STRING", "KING" 에서 "IN" 을 검색하면 문자열 검색 성공

    - ex) 문자열 "QUEEN" 에서 "IN" 을 검색하면 문자열 검색 실패

* 검색할 문자열을 패턴(pattern), 문자열 원본을 텍스트(text) 라 한다

### 브루트-포스법

* 가능한 모든 경우의 수를 전부 탐색하여 정답을 찾아내는 알고리즘

    - 가능한 모든 조합이나 순서를 하나씩 검사하여 정답을 찾는다

    - 예를 들어, 숫자 1부터 100까지의 숫자 중 특정 조건을 만족하는 값을 찾는다면, 1부터 100까지 하나씩 확인한다

    - 그러므로 문제 해결이 가능하다는 보장이 있지만, 경우의 수가 많아지면 시간 복잡도가 매우 커질 수 있다

    - 일치하지 않는 문자를 만나면 그때가지 검사한 결과를 버리고 패턴을 텍스트의 다음 칸으로 옮긴 다음 패턴의 첫 문자부터 다시 검사한다

    - 범용적인 알고리즘으로 문자열 전용 알고리즘이 아니다

* 시간 복잡도 O(mn). 실질적인 시간 복잡도는 O(n)
    
* 예시

    ```java
    // 브루트-포스법을 사용해 배열 a 에서 "ABC" 검색

    String[] a = {"A", "B", "A", "B", "C", "D", "E"}

    1. 패턴이 텍스트의 첫 문자와 겹치도록 놓고 첫번째 문자부터 순서대로 일치하는지 검사 시작

        텍스트 = {"A", "B", "A", "B", "C", "D", "E"}

        패턴 =   {"A", "B", "C"}

    2. 첫번째 텍스트와 패턴 모두 A 로 일치 -> 일치한다면 계속해서 패턴과 텍스트의 문자 검사

    3. 두번째 B 일치 -> 세번째 텍스트는 A, 패턴은 C 로 불일치

    4. 서로 다른 문자가 나타나면 검사를 멈추고 텍스트의 2번째 문자와 겹치도록 패턴의 위치를 1칸 뒤로 이동

        텍스트 = {"A", "B", "A", "B", "C", "D", "E"}

             패턴 =   {"A", "B", "C"}

    5. 검사 시작 -> 첫번째 문자부터 불일치 -> 다시 패턴을 1칸 뒤로 이동

        텍스트 = {"A", "B", "A", "B", "C", "D", "E"}

                  패턴 =   {"A", "B", "C"}

    6. 검사 시작 -> 첫번째, 두번째, 세번째 모두 일치 -> 검색 성공
    ```

* 구현

    ```java
    class BFmatch {

        // 브루트-포스법 으로 문자열 검색
        static int bfMatch(String txt, String pat) {
            int pt = 0;        // txt 커서
            int pp = 0;        // pat 커서

            while (pt != txt.length() && pp != pat.length()) {
                if (txt.charAt(pt) == pat.charAt(pp)) { // String.charAt(int index) : 전체 문자열 중 인자로 넘어온 인덱스에 위치한 문자 하나만 char 로 바꿔 반환
                    pt++;
                    pp++;
                } else { // 불일치 시 텍스트는 1칸씩 뒤로, 패턴은 0으로 초기화
                    pt = pt - pp + 1;
                    pp = 0;
                }
            }
            if (pp == pat.length())        // 검색 성공
                return pt - pp;
            return -1;                     // 검색 실패
        }

        public static void main(String[] args) {
            Scanner stdIn = new Scanner(System.in);

            System.out.print("텍스트: ");
            String s1 = stdIn.next();                     // 텍스트용 문자열

            System.out.print("패  턴: ");
            String s2 = stdIn.next();                     // 패턴용 문자열

            int idx = bfMatch(s1, s2);    // 문자열 s1에서 문자열 s2를 브루트-포스법으로 검색

            if (idx == -1)
                System.out.println("텍스트 안에 패턴이 없습니다.");
            else {
                // 일치하는 문자 바로 앞까지의 문자 개수를 반각 문자로 환산하여 구함
                int len = 0;
                for (int i = 0; i < idx; i++)
                    len += s1.substring(i, i + 1).getBytes().length;
                len += s2.length();

                System.out.println((idx + 1) + "번째 문자부터 일치합니다.");
                System.out.println("텍스트: " + s1);
                System.out.printf(String.format("패  턴: %%%ds\n", len), s2);
            }
        }
    }
    ```

### KMP 법

* 텍스트와 패턴 사이에 겹치는 부분을 찾아내 검사를 다시 시작할 위치를 구하여 패턴을 한번에 많이 옮기는 알고리즘

    - 문자열 검색 전용 알고리즘

* 예시

    ```java
    // KMP 법을 사용해 배열 a 에서 {"A", "B", "C", "A", "B", "D"} 를 검색

    String a = {"Z", "A", "B", "C", "A", "B", "X", "A", "C", "C"}

    1. 배열 a 에서 패턴 검색

        텍스트 : {"Z", "A", "B", "C", "A", "B", "X", "A", "C", "C"}

        패턴 :   {"A", "B", "C", "A", "B", "D"}

    2. 첫번재 문자부터 불일치 ->  텍스트와 패턴 사이에 일치하는 부분이 있는지 찾음
    
    3. 없으므로 패턴을 1칸 뒤로 옮김

        텍스트 : {"Z", "A", "B", "C", "A", "B", "X", "A", "C", "C"}

             패턴 :   {"A", "B", "C", "A", "B", "D"}

    4. 두번째 ~ 여섯번째 까지 일치하지만 마지막 문자 불일치

    5. 텍스트와 패턴 사이에 일치하는 부분이 있는지 찾음
    
    6. 텍스트의 5, 6 인덱스의 A,B 가 텍스트와 일치함 -> 3칸 뒤로 이동

        텍스트 : {"Z", "A", "B", "C", "A", "B", "X", "A", "C", "C"}

                            패턴 :   {"A", "B", "C", "A", "B", "D"}
                    
    7. 패턴의 3번째 문자부터 검사 시작
    ```

### 보이어-무어법

* 패턴의 마지막 문자부터 앞쪽으로 검사를 진행하며 일치하지 않는 문자가 있으면 미리 준비한 표에 따라 패턴을 옮길 크기를 정하는 알고리즘

    - KMP 법 보다 이론과 실제 모두에서 더 우수한 알고리즘

    - 문자열 검색 전용 알고리즘으로 긴 텍스트에서 특정 패턴을 빠르게 찾는 데 최적화된 방법이다

* 예시

    ```java
    // 보이어-무어법을 사용해 배열 a 에서 {"A", "B", "A", "C"} 를 검색

    String a = {"A", "B", "C", "X", "D", "E", "Z", "C", "A", "B", "A", "C"}

    1. 텍스트와 패턴의 첫번째 문자를 겹치고 패턴의 마지막 문자(C) 부터 검사

        텍스트 : {"A", "B", "C", "X", "D", "E", "Z", "C", "A", "B", "A", "C"}

        패턴 :   {"A", "B", "A", "C"} 

    2. 패턴은 C, 텍스트는 X 로 불일치

    3. 텍스트의 X는 패턴에 없으므로 패턴을 1 ~ 3칸 옮겨도 패턴과 일치하는 경우는 없음

        텍스트 : {"A", "B", "C", "X", "D", "E", "Z", "C", "A", "B", "A", "C"}

             패턴 :   {"A", "B", "A", "C"} 

                  패턴 :   {"A", "B", "A", "C"} 

                       패턴 :   {"A", "B", "A", "C"} 

    4. 그러므로 패턴을 단숨에 4칸 뒤로 옮겨 비교

        텍스트 : {"A", "B", "C", "X", "D", "E", "Z", "C", "A", "B", "A", "C"}

                            패턴 :   {"A", "B", "A", "C"}

    5. 텍스트의 Z 는 패턴에 없는 문자이므로 뒤로 3칸 옮겨 다시 비교

        텍스트 : {"A", "B", "C", "X", "D", "E", "Z", "C", "A", "B", "A", "C"}

                                           패턴 :   {"A", "B", "A", "C"}

    6. 마지막 문자부터 비교 -> A 와 C로 불일치 -> 그런데 텍스트의 A는 패턴의 1, 3 인덱스에 있음

    7. 이런 경우 뒤쪽에 위치한 A (3번 인덱스의 A) 가 텍스트와 겹치도록 패턴을 1칸만 옮김

        텍스트 : {"A", "B", "C", "X", "D", "E", "Z", "C", "A", "B", "A", "C"}

                                                패턴 :   {"A", "B", "A", "C"}

    8. 패턴의 마지막 위치부터 순서대로 문자 비교 -> 모두 일치하므로 검색 성공
    ```
