### 리스트

* 데이터를 순차적으로 저장하는 자료구조

    - 데이터가 삽입된 순서를 유지한다

        - 데이터가 A, B, C 순서로 삽입되면 항상 이 순서를 유지

    - 동일한 값을 가진 데이터를 중복해서 저장할 수 있다

    - 리스트의 크기는 동적으로 변경 가능하다

        - 배열 기반 리스트 : 배열 크기를 늘려 데이터 저장

        - 연결 리스트 : 노드를 추가하거나 삭제하면서 크기 조정

    - 데이터 삽입/삭제가 가능하며, 특정 위치에서도 수행할 수 있다

        - 삽입/삭제의 효율은 구현 방식에 따라 달라짐

    - 데이터 접근 방식은 구현 방식에 따라 달라진다

        - 배열 기반 리스트 : 인덱스를 사용해 데이터에 임의 접근 가능

        - 연결 리스트 : 순차 접근을 통해 데이터를 검색

* 선형 구조를 갖는 리스트에 선형 리스트(linear list), 연결 리스트(linked list) 가 있다

### 선형 리스트(linear list : 배열 기반 리스트)

* 데이터가 배열처럼 연속된 메모리 공간에 저장된다

* 특징

    - 배열로 구현 가능하고, 배열과 거의 비슷하나 조금 다른점이 있다

    - 삽입/삭제 시 데이터 이동이 필요하므로 속도가 느림. 시간 복잡도 O(n)

        - 선형 리스트 구조는 데이터를 삽입하면 삽입된 위치 이후의 모든 요소를 한칸씩 뒤로 옮긴다

        - 삭제할 때도 삭제한 요소 이후의 모든 요소를 앞으로 당긴다

    - 데이터 접근 속도가 빠르다. 시간 복잡도 O(1)

* 동적 크기 조절 방식

    - 데이터가 배열의 크기를 초과하면 더 큰 배열을 생성하고, 기존 데이터를 새로운 배열에 복사

    - 과정

        - 데이터가 추가될 때, 현재 배열의 빈 공간이 부족하면 더 큰 배열 생성 (보통 현재의 2배)

            - 배열 크기를 2배로 늘리는 것은 데이터를 추가할 때마다 조금씩 늘리면 배열 복사 작업이 너무 잦아질 수 있음

        - 기존 배열에 저장된 데이터를 새로운 배열로 복사

        - 기존 배열을 참조하던 변수가 기존 배열 대신 새 배열을 가리키도록 업데이트

        - 기존 배열은 참조되지 않으므로 GC가 메모리 해제시킴 

### 연결 리스트(linked list)

<img src="https://github.com/user-attachments/assets/b9007420-99b4-441f-9f99-3f9e460dbdf5">

* 데이터가 노드(Node)에 저장되며, 각 노드가 포인터로 다음 노드를 가리키는 방식으로 구성

    - 데이터가 메모리 공간에 연속적으로 저장되어 있지 않더라도, 각각의 데이터 안에 다음 데이터에 대한 정보를 갖고 있어 서로 연결된다

    - 메모리가 연속적으로 할당되지 않아도 작동 가능

* 연결 리스트의 구성 요소

    - 노드(node) : 연결 리스트의 개별 요소 (그림의 A ~ F 모두 하나의 노드)

        - 노드의 구성 요소 : 데이터와 다음 노드를 가리키는 포인터로 구성

    - 처음에 있는 노드를 머리 노드(head node), 끝에 있는 노드를 꼬리 노드(tail node) 라고 한다

    - 하나의 노드를 기준으로 바로 앞의 노드를 앞쪽 노드, 바로 뒤의 노드를 다음 노드 라고 한다

        - 노드 C의 앞쪽 노드는 B, 뒤의 노드는 D

* 특징

    - 데이터 접근 속도가 느리다. 시간 복잡도 O(n)

        - 순차 접근의 특징을 가지고 있어 데이터가 저장된 위치에 따라 검색 시간이 다르다

        - E 를 검색하면 노드 A 접근 -> A의 포인터로 B 위치 탐색 -> 노드 B 접근 -> 포인터.. 방법으로 E 까지 접근한다

        - 이런 특성 때문에 데이터의 위치가 리스트 끝에 가까울수록 탐색 시간이 길어진다

    - 데이터 삽입/삭제가 빠르다. 시간 복잡도 O(1)

    - 메모리 사용량 증가(포인터 공간 필요)

    - 크기 조절이 필요 없이 데이터를 삽입하거나 삭제할 때마다 자동으로 크기가 변동

* 동적 크기 조절 방식

    - 데이터가 노드 단위로 저장되므로 데이터 추가/삭제 시 동적으로 메모리를 할당하거나 해제

        - 배열처럼 복사 작업이 필요하지 않음

    - 과정

        - 데이터 추가

            - 새로운 데이터를 저장할 노드를 동적으로 메모리에 생성

            - 기존 리스트에 새로운 노드를 연결(포인터 조정)

        - 데이터 삭제

            - 삭제된 데이터를 포함한 노드의 메모리를 해제

            - 이전/다음 노드의 포인트를 조정하여 리스트를 연결

* 포인터로 연결 리스트 구현

    ```java

    ```
