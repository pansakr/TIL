### 정렬 알고리즘

* 정렬

    - 이름, 학번, 키 등 기준 항목의 대소 관계에 따라 데이터 집합을 일정한 순서로 나열하는 작업

    - 정렬을 사용하는 정렬 알고리즘의 핵심은 교환, 선택, 삽입이다

    - 내부 정렬을 사용하는 알고리즘, 외부 정렬을 알고리즘으로 나뉜다

* 내부 정렬

    - 정렬할 모든 데이터를 하나의 배열에 저장할 수 있을 때 사용하는 알고리즘

    - 아래에 정리된 모든 정렬 알고리즘들은 내부 정렬 방식이다

* 외부 정렬

    - 정렬할 데이터가 많아서 하나의 배열에 저장할 수 없을 때 사용하는 알고리즘

    - 내부 정렬을 응용한 것으로, 구현하려면 작업을 위한 별도의 파일이 필요하고 알고리즘도 복잡하다

### 버블 정렬 (단순 교환 정렬)

* 이웃한 두 교환 요소의 대소 관계를 비교하고 필요에 따라 교환을 반복하는 알고리즘

    - 비교, 교환 과정을 패스라고 한다

        - 제일 끝 요소를 모든 요소와 비교, 교환 하는것이 패스 1번이고 마지막 요소를 제외한 모든 요소들에 패스를 진행하여 정렬한다

        - 마지막 요소는 정렬이 끝나면 이미 끝에 놓이기 때문에 정렬할 필요가 없다
        
        - 그러므로 요소 수를 n 이라 할 때 패스 진행 횟수는 n - 1 이다

        - 만약 5개의 요소를 가진 배열이 있다면 이 배열이 버블 정렬 하는데 걸리는 패스는 4번

* 시간 복잡도 : O(n²). 업무에서 잘 사용되지 않음

* 예시

    ```java
    // 버블 정렬을 사용해 배열 a를 오름차순 정렬

    int[] a = {6, 4, 3, 7, 1, 9, 8}

    // 버블 정렬 시 내부 동작
    // 오름차순으로 정렬하려면 왼쪽 값이 오른쪽 값보다 작아야 한다
    // 끝 요소부터 첫번째 요소까지 모든 요소들을 차례로 비교 후 교환

    // 패스 1
    1-0. 먼저 끝 인덱스의 요소 부터 시작

    1-1. 9와 8을 비교 -> 왼쪽 값인 9가 오른쪽 값인 8보다 크기 때문에 둘을 교환
        결과 -> {6, 4, 3, 7, 1, 8, 9}

    1-2. 1과 8을 비교 -> 왼쪽 값인 1은 오른쪽 값인 8보다 작으므로 교환하지 않음
        결과 -> {6, 4, 3, 7, 1, 8, 9}

    1-3. 7과 1을 비교 -> 교환
        결과 -> {6, 4, 3, 1, 7, 8, 9}

    1-4. 3과 1을 비교 -> 교환
        결과 -> {6, 4, 1, 3, 7, 8, 9}

    1-5. 4와 1을 비교 -> 교환
        결과 -> {6, 1, 4, 3, 7, 8, 9}

    1-6. 6과 1을 비교 -> 교환
        결과 -> {1, 6, 4, 3, 7, 8, 9}

    1-7. 첫 번째 패스 결과 -> {1, 6, 4, 3, 7, 8, 9}

    // 패스 2
    2-0. 그다음 인덱스의 요소 시작

    2-1. 8과 9를 비교 -> 교환 x
        결과 -> {1, 6, 4, 3, 7, 8, 9}

    2-2. ...

    // 요소 수가 7(n)개인 배열이므로 위와 같은 방법으로 7(n) - 1 번 패스가 진행
    ```

* 구현

    ```java
    public class BubbleSort {

        // a[idx] 와 a[idx2] 의 값을 교환
        static void swap(int[] a, int idx1, int idx2){
            int t = a[idx1];
            a[idx1] = a[idx2];
            a[idx2] = t;
        }

        // 버블 정렬
        static void bubbleSort(int[] a, int n){
            for (int i = 0; i < n - 1; i++){        // i값 = 패스를 진행하는 횟수. 요소수가 n 일때 패스 회수는 n - 1
                for (int j = n - 1; j > i; j--){    // 마지막 요소와 그 직전 요소부터 비교 시작
                    if (a[j - 1] > a[j]){           // 왼쪽 요소가 오른쪽 요소보다 크다면 둘을 교환
                        swap(a, j - 1, j);
                    }
                }
            }
        }

        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);

            System.out.println("버블 정렬");
            System.out.print("요소 수: ");
            int nx = sc.nextInt();
            int[] x = new int[nx];

            // 배열 요소 입력
            for (int i = 0; i < nx; i++){
                System.out.print("x[" + i + "]: ");
                x[i] = sc.nextInt();
            }

            bubbleSort(x, nx);  // 배열 x를 버블 정렬

            System.out.println("오름차순으로 정렬되었습니다");

            for (int i = 0; i < nx; i++){
                System.out.println("x[" + i + "]=" + x[i]);
            }
        }
    }
    ```

### 단순 선택 정렬

* 가장 작은 요소를 맨 앞으로 이동하고, 두번째 작은 요소를 맨 앞에서 두번째로 이동하는 작업을 반복하는 알고리즘

* 시간 복잡도 : O(n²). 업무에서 잘 사용되지 않음

* 예시

    ```java
    // 단순 선택 정렬을 사용해 배열 a를 오름차순 정렬

    int[] a = {6, 4, 8, 3, 1, 9, 7}

    // 아직 정렬하지 않은 부분에서 가장 작은 요소를 아직 정렬하지 않은 부분의 첫 요소와 교환한다
    // ex) 가장 작은 요소를 0 인덱스와 교환, 두번째로 작은 요소를 1인덱스와 교환.. 반복  

    0. 가장 작은 요소부터 정렬하므로 1을 선택해 정렬 시작 
    
    1. 1과 6을 교환 -> 결과 {1, 4, 8, 3, 6, 9, 7}

    2. 3과 4를 교환 -> 결과 {1, 3, 8, 4, 6, 9, 7}

    3. 제일 큰 요소까지 반복
    ```

* 구현

    ```java
    class SelectionSort {
        // 배열 요소 a[idx1]와 a[idx2]의 값을 교환
        static void swap(int[] a, int idx1, int idx2) {
            int t = a[idx1];
            a[idx1] = a[idx2];
            a[idx2] = t;
        }

        // 단순 선택 정렬
        static void selectionSort(int[] a, int n) {
            for (int i = 0; i < n - 1; i++) {
                int min = i;                // 아직 정렬되지 않은 부분에서 가장 작은 요소의 인덱스를 저장
                for (int j = i + 1; j < n; j++){    // 제일 작은 값을 가지고 있는 요소 찾기
                    if (a[j] < a[min]) {
                        min = j;
                    }
                }
                swap(a, i, min);           // 아직 정렬되지 않은 부분의 첫 요소와 가장 작은 요소를 교환
            }
        }

        public static void main(String[] args) {
            Scanner stdIn = new Scanner(System.in);

            System.out.println("단순 선택 정렬");
            System.out.print("요소 수: ");
            int nx = stdIn.nextInt();
            int[] x = new int[nx];

            for (int i = 0; i < nx; i++) {
                System.out.print("x[" + i + "] : ");
                x[i] = stdIn.nextInt();
            }

            selectionSort(x, nx);            // 배열 x를 단순 선택 정렬

            System.out.println("오름차순으로 정렬되었습니다.");
            for (int i = 0; i < nx; i++)
                System.out.println("x[" + i + "]=" + x[i]);
        }
    }
    ```

### 단순 삽입 정렬

* 선택한 요소를 그보다 앞쪽의 알맞은 위치에 삽입하는 작업을 반복해 정렬하는 알고리즘

    - 선택한 요소를 앞쪽에 삽입해야 하므로 두번째 요소부터 정렬을 시작한다

* 정렬이 되었거나 정렬된 상태에 가까우면 정렬 속도가 매우 빠르다

    - 그러나 삽입할 곳이 멀리 떨어지면 이동하는 횟수가 많아져 성능이 떨어진다

* 시간 복잡도 : O(n²). 업무에서 잘 사용되지 않음

* 예시

    ```java
    // 단순 삽입 정렬을 사용해 배열 a를 오름차순 정렬

    int[] a = {6, 4, 1, 7, 3, 9, 8}

    // 아직 정렬하지 않은 부분의 첫 번째 요소를 정렬한 부분의 알맞은 위치에 삽입
    // 단 첫 시작은 전체 요소의 두번째 요소를 앞쪽(첫번째 요소) 와 비교해 삽입 

    0. 두 번째 요소부터 정렬하므로 4를 선택해 정렬 시작 
    
    1. 4를 앞쪽의 알맞은 위치로 삽입 -> 4는 6보다 작으므로 6의 앞쪽으로 이동
        결과 -> {4, 6, 1, 7, 3, 9, 8}

    2. 1을 앞쪽의 알맞은 위치로 삽입 -> 1은 4, 6 보다 작으므로 4의 앞쪽으로 이동
        결과 -> {1, 4, 5, 7, 3, 9, 8}

    3. 마지막 요소까지 반복

    // 그러나 자바에는 '배열의 알맞은 위치에 삽입' 명령이 없다
    // 그래서 구체적으로는 '선택 요소보다 작은 요소를 만날 때가지 이웃한 왼쪽의 요소를 한칸 오른쪽에 대입' 하는 작업을 반복한다

    // 3인 요소를 선택해 앞쪽의 알맞은 위치에 삽입하는 과정
    a = {1, 4, 6, 7, 3, 9, 8}

    1. 첫번째 왼쪽의 요소(7) 가 선택 요소(3) 보다 크니 3자리에 7을 대입 
        결과 -> {1, 4, 6, 7, 7, 9, 8}
    
    2. 두번째 왼쪽의 요소(6) 가 선택 요소(3) 보다 크니 한칸 오른쪽에 대입
        결과 ->  {1, 4, 6, 6, 7, 9, 8}

    3. 세번째 왼쪽의 요소(4) 가 선택 요소(3) 보다 크니 한칸 오른쪽에 대입
        결과 -> {1, 4, 4, 6, 7, 9, 8}

    4. 네번째 왼쪽의 요소(1) 가 선택 요소(3) 보다 작으니 한칸 오른쪽에 선택 요소를 대입
        결과 -> {1, 3, 4, 6, 7, 9, 8}
    ```

### 셸 정렬

* 단순 삽입 정렬을 기반으로 장점을 살리고 단점을 보완해 더 빠르게 정렬하는 알고리즘

*  특정 간격을 두고 요소를 비교하고 정렬하는 방식으로, 이 간격이 점점 줄어들면서 마지막에는 간격이 1이 되어 일반적인 삽입 정렬을 수행

    - 4정렬 -> 2정렬 -> 1정렬 순서대로 정렬한다

        - 4정렬

            - 4칸 떨어져 있는 요소들로 그룹짓는다
            
                - 예: 리스트가 [13, 14, 94, 33, 82, 25, 32, 62]라면
                
                - 첫 번째 그룹: [13, 82]
                
                - 두 번째 그룹: [14, 25]
                
                - 세 번째 그룹: [94, 32]
                
                - 네 번째 그룹: [33, 62]
            
            - 각 그룹 내에서 단순 삽입 정렬을 수행

        - 2정렬 : 2칸 떨어져 있는 요소들로 그룹짓고 그룹별로 단순 삽입 정렬

        - 1정렬 : 단순 삽입 정렬 수행

* 시간 복잡도 O(n^1.25). 업무에서 잘 사용되지 않음

* 예시

    ```java
    // 셸 정렬을 사용해 배열 a를 오름차순 정렬

    int[] a = {8, 1, 4, 2, 7, 6, 3, 5}


    1. 4정렬 시작 -> {8, 7}, {1, 6}, {4, 3}, {2, 5} 로 나누고 그룹별로 정렬

    2. {8, 7} 에 단순 삽입 정렬 수행 -> 8이 7보다 크기 때문에 위치 변경
        결과 ->  {7, 1, 4, 2, 8, 6, 3, 5}

    3. {1, 6} 에 단순 삽입 정렬 수행 -> 1이 6보다 작으므로 변화 없음
        결과 -> {7, 1, 4, 2, 8, 6, 3, 5}

    4. 모든 그룹에 대해 반복
        결과 -> {7, 1, 3, 2, 8, 6, 4, 5}

    5. 2정렬 시작 -> {7, 3, 8, 4}, {1, 2, 6, 5} 로 나누고 그룹별로 정렬

    6. {7, 3, 8, 4} 에 단순 삽입 정렬 수행
        결과 -> {3, 1, 4, 2, 7, 6, 8, 5}

    7. {1, 2, 5, 6} 에 단순 삽입 정렬 수행
        결과 -> {3, 1, 4, 2, 7, 5, 8, 6}

    8. 1정렬 시작 -> {1, 2, 3, 4, 5, 6, 7, 8}
    ```

### 퀵 정렬

* 피벗을 기준으로 데이터를 분할하고, 각 부분을 재귀적으로 정렬하는 빠른 알고리즘

* 각 그룹에 대해 피벗 설정과 그룹 나눔을 반복해 모든 그룹이 1명이 되면 정렬을 마친다

    - 피벗 : 그룹을 나누는 기준

* 시간 복잡도 O(n log n), 최악의 경우 O(n^2). 자주 사용됨

* 동작 순서

    - 피벗 선택

        - 배열에서 임의의 원소(보통 첫 번째, 마지막, 중앙 값, 또는 랜덤 값)를 피벗으로 선택

    - 분할
    
        - 피벗보다 작은 값들은 왼쪽 부분으로, 피벗보다 큰 값들은 오른쪽 부분으로 나눈다

        - 분할 과정이 끝난 뒤, 피벗은 정렬된 위치에 놓이게 된다

    - 재귀적 정렬

        - 분할된 두 부분 배열(피벗보다 작은 값들과 큰 값들)에 대해 동일한 방법으로 퀵 정렬을 재귀적으로 수행

    - 종료 조건

        - 배열의 크기가 1 이하가 되면 정렬이 완료된 것으로 간주

* 예시

    <img src="https://github.com/user-attachments/assets/71ec900c-3266-4f25-936b-a48dad0e2b4a">

    - 퀵 정렬을 사용해 {175, 170, 160, 168, 165, 170, 155, 150} 를 오름차순 정렬

    - 요소 중 하나를 피벗으로 선택(168)

    - 168을(피벗) 기준으로 168 이하인 그룹과 이상인 그룹으로 나눔 -> 현재 2 그룹

    - 나눠진 두 그룹에서 각각 피벗을 설정해 다시 그룹을 나눔 -> 현재 4 그룹

    - 나눠진 네 그룹에서 각각 피벗을 설정해 다시 그룹을 나눔 -> 현재 8 그룹

    - 각 그룹의 크기가 1이므로 정렬 완료

### 병합 정렬

* 앞부분과 뒷부분 둘로 분할해 각각 정렬한 다음 병합하는 작업을 반복하는 알고리즘

* 동작 과정

    - 분할(Divide)

        - 배열을 더 이상 나눌 수 없는 크기(1)로 분할

    - 병합(Merge)

        - 나눠진 배열을 두 개씩 병합하며 정렬

    - 최종 정렬된 배열

        - 모든 병합이 끝나면 정렬 
        
* 시간 복잡도는 O(n log n). 자주 사용됨

* 예시

    - 정렬을 완료한 배열의 병합 (병합 정렬 아님)

    ```java
    class MergeArray {

        // 정렬을 마친 배열 a, b를 병합하여 배열 c에 저장
        static void merge(int[] a, int na, int[] b, int nb, int[] c) { // na = 배열 a의 길이, nb = 배열 b의 길이
            int pa = 0;
            int pb = 0;
            int pc = 0;

            // pa, pb 가 배열 a, b 의 길이 (pa, pb) 보다 작을때 반복
            while (pa < na && pb < nb)         
                c[pc++] = (a[pa] <= b[pb]) ? a[pa++] : b[pb++];  // 작은 쪽을 c에 넣고 작은 쪽과 c의 인덱스 1 증가. 큰 쪽은 인덱스 증가하지 않음 

            while (pa < na)                   // a에 남아있는 요소를 복사
                c[pc++] = a[pa++];

            while (pb < nb)                   // b에 남아있는 요소를 복사
                c[pc++] = b[pb++];
        }

        public static void main(String[] args) {

            int[] a = {2, 4, 6, 8, 11, 13};
            int[] b = {1, 2, 3, 4, 9, 16, 21};
            int[] c = new int[13];

            System.out.println("두 개의 배열을 병합");

            merge(a, a.length, b, b.length, c);      // 배열 a와 b를 병합하여 c에 넣어 둠

            System.out.println("배열 a와 b를 병합하여 배열 c에 저장");
            System.out.println("배열 a: ");
            for (int i = 0; i < a.length; i++)
                System.out.println("a[" + i + "] = " + a[i]);

            System.out.println("배열 b: ");
            for (int i = 0; i < b.length; i++)
                System.out.println("b[" + i + "] = " + b[i]);

            System.out.println("배열 c: ");
            for (int i = 0; i < c.length; i++)
                System.out.println("c[" + i + "] = " + c[i]);
        }
    }
    ```

    - 병합 정렬

        - 위 과정을 응용해 분할 정복법에 따라 정렬

    ```java
    // 병합 정렬을 사용해 배열 a를 오름차순 정렬
    
    int[] a = {5, 3, 8, 6, 2, 7, 4, 1}

    1. 앞부분과 뒷부분으로 나눔

        앞 : {5, 3, 8, 6}, 뒤 : {2, 7, 4, 1}

    2. 앞, 뒤 부분을 다시 앞 뒤로 나눔

        앞 : {5, 3}, 뒤 : {8, 6}, 앞 : {2, 7}, 뒤 : {4, 1}

    3. 배열의 크기가 1이 될때까지 반복해서 앞, 뒤로 나눔

        - 크기가 1인 배열은 정렬된 상태로 간주하기 때문

        {5}, {3}, {8}, {6}, {2}, {7}, {4}, {1}

    4. 최소로 나누어진 배열을 정렬된 상태로 병합

        {5}, {3} 병합 -> {3, 5}

        {8}, {6} 병합 -> {6, 8}

        {2}, {7} 병합 -> {2, 7}

        {4}, {1} 병합 -> {1, 4}

    5. 하나의 배열이 될때까지 나뉘어진 모든 배열을 병합

        {3, 5}, {6, 8} 병합 -> {3, 5, 6, 8}

        {2, 7}, {1, 4} 병합 -> {1, 2, 4, 7}

        {3, 5, 6, 8}, {1, 2, 4, 7} 병합 -> {1, 2, 3, 4, 5, 6, 7, 8}
    ```

* Arrays.sort 로 퀵/병합 정렬 사용

    - 기본 자료형 배열은 퀵 정렬이 사용됨

    - 객체 배열은 병합 정렬이 사용됨

        - 자연스러운 순서를 갖고 있는 배열을 정렬

            - 배열들이 이미 어떤 기준으로 정렬될 수 있는 방법이 있을때 사용

            - ex) Integer: 오름차순 (1, 2, 3, …), String: 알파벳순 ("apple", "banana", …)

            ```java
            sort(Object [] a)
            sort(Object [] a, int fromIndex, int toIndex)
            ```

        - 자연스러운 순서를 갖고 있지 않은 배열을 정렬

            - 요소들을 정렬할 기준이 없는 경우 사용

            - 정렬 기준을 직접 제공하기 위해 Comparator 인터페이스 사용

            ```java
            static <T> void sort(T[] a, Comparator<? super T> c)
            static <T> void sort(T[] a, int fromIndex, int toIndex, Comparator<? super T> c)
            ```

### 힙 정렬

* 

### 도수 정렬

* 
