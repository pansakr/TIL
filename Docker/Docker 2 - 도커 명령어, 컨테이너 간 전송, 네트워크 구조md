### 도커 명령어

* 도커 이미지 실행 : docker run [이미지 이름] 또는 docker container run [이미지 이름] (권장)

    - [이미지 이름] 라는 도커 이미지를 기반으로 컨테이너를 생성하고 실행하는 명령

* 도커 이미지 빌드 : docker build -t [이미지 이름] [경로]

    - 예시) docker build -t nginx ./nginx

    - docker build : 도커 이미지 빌드 명령어

    - -t : 빌드된 이미지에 붙일 이름

        - -t 는 -tag 의 약자

        - -t nginx : 이미지 이름을 nginx 로 설정

    - ./nginx : 이미지 빌드 시 사용할 경로

        - Dockerfile이 위치한 디렉토리 경로

* 도커 이미지 다운로드

    - docker image pull [이미지 이름:태그이름]

        - ex) docker image pull ubuntu
        
        - ex) docker image pull python:3.11.6

        - 이미지가 없을 경우 레지스트리에서 해당 이미지 다운로드

        - 태그명을 입력하지 않으면 자동으로 latest 가 적용됨

            - 도커 허브 -> 해당 이름의 이미지 중 latest 태그의 이미지를 다운로드한다는 뜻

            - 도커 허브에는 하나의 이미지 이름에 여러 태그가 있다

        - 이미지 다운 완료 시 해당 이미지의 레이어 개수 만큼 Pull complete 메시지 출력됨

        - 그 밑에 Diget 가 출력되는데, 이것은 다운로드한 모든 레이어와 메타정보를 포함하는 이미지의 해시값이다

        - docker image pull [이미지 이름@Digest] 로도 이미지 다운이 가능하다

    - 도커 이미지는 이미지 인덱스, 이미지 매니페스트, 레이어 의 구조로 이루어져 있다

        - 이미지 인덱스는 여러 개의 이미지 매니페스트로 이루어져 있고, 하나의 이미지 매니페스트는 여러 개의 레이어로 이루어져 있다

            - 이미지 인덱스, 매니페스트, 레이어는 각각 인덱스 값을 가지고 있다

        - 도커 이미지 다운로드 시 출력되는 Digest 는 이미지 인덱스의 값이다

        - 그 외에 출력되는 값들은 이미지 인덱스를 구성하고 있는 매니페스트의 레이어의 값이다

        - 이를 통해 어떤 레이어를 다운로드 하는지 확인할 수 있다

* 도커 이미지 목록 확인 : docker image ls

    - 다운로드한 이미지 목록 확인

    - Repository 는 이미지 이름,  Tag 는 이미지 태그, Image id 는 다운로드한 이미지의 Id

* 실행 중인 컨테이너 확인 : docker container ls

* 실행, 정지 상태의 컨테이너 확인 : docker container ls -a

* 실행 중 컨테이너 종료 : docker container stop [컨테이너 ID]

* 컨테이너 삭제 : docker container rm [컨테이너 ID]

    - 컨테이너마다 레이어와 로그가 있어서 조금씩 용량을 차지하기 때문에 주기적으로 삭제해 줘야 한다

    - docker container ls -a 입력해서 전체 컨테이너 목록 확인

    - 삭제할 컨테이너의 container id 확인 후 삭제

        - 하나의 이미지로 다수의 컨테이너를 생성할 수 있으므로 각 컨테이너는 container id 를 가진다

    - 이미지를 기반으로 만들어진 실행 중인 프로세스 인스턴스를 삭제하는 것

    - 해당 컨테이너가 점유하던 리소스가 해제됨

* 종료된 컨테이너 모두 삭제 : docker container prune

* 도커 이미지 삭제 : docker image rm [image ID]

    - docker image ls 입력

    - 삭제할 이미지 id 확인 후 삭제

    - 컨테이너를 만들기 위한 원본 코드가(설치 파일과 유사) 삭제됨

* 정지 상태의 컨테이너 재실행 : docker container start [컨테이너 ID]

* 컨테이너 내부 접속

    - docker container run -it [이미지 이름]

        - 컨테이너를 실행할 때 -it 옵션을 사용해 컨테이너 내부 접속

        - 컨테이너 내부이므로 사용자 이름과 호스트 이름이 변경된다

            - 사용자 이름은 root, 호스트 이름은 컨테이너 id

            - 사용자 이름 : 로그인한 사람/계정 이름

            - 호스트 이름 : 컴퓨터의(서버) 이름

                - 도커에서는 컨테이너 내부 접속 시 컨테이너의 이름이 호스트 이름이 된다

    - docker container attach [컨테이너 ID]

        - 실행 중인 컨테이너 내부 접속

* 도커 이미지 새로운 버전 생성

    - docker container run -it ubuntu 입력 -> ubuntu 컨테이너 생성과 동시에 내부 접속

    - apt install net-tools 명령어로 net-tools 패키지 설치

    - 설치 완료시 ifconfig 명령어 사용 가능

    - 기존 터미널 종료하지 말고 새로운 터미널 실행 (ssh 사용)

    - docker container ls 입력 시 터미널 1에서 작업했던 컨테이너가 실행중임을 확인할 수 있음

    - docker container commit [컨테이너 ID] my-ubuntu:0.1 입력해 새로운 버전 생성

        - 이 버전은 기존 ubuntu 에 net-tools 패키지가 설치된 버전

    - 기존 터미널에서 exit 로 ubuntu 컨테이너 종료 -> docker image ls 입력 시 터미널 2에서 생성한 my-ubuntu 이미지 확인 가능

    - 해당 이미지 실행 시 ifconfig 명령어 사용 가능

### 도커와 도커 컨테이너의 네트워크 구조

* 기본 네트워크 인터페이스 상태

    - 도커가 설치될 리눅스 우분투 서버에는 기본적으로 eth0 네트워크 인터페이스가 설치되어 있음

    - eth0, eth1 ..

        - 리눅스에서 사용되는 기본 유선 네트워크 인터페이스 이름

        - eth0 는 첫번째(0) 유선 네트워크 인터페이스(eth) 라는 의미

        - 무선 네트워크를 사용해도 가상머신에서는 항상 유선으로 인식
        
        - 그래서 무선 네트워크를 사용중이어도 eth.. 의 유선 네트워크 인터페이스 이름으로 표시됨 

* 도커 설치 시 도커 호스트에 docker0 라는 네트워크 인터페이스가 설치된다

* 도커 컨테이너 실행 시 해당 컨테이너 내부를 보면 자체적으로 eth0 인터페이스를 가지고 있다

    - eth0 장치가 외부와(도커 호스트) 통신하기 위한 네트워크 인터페이스이다    

* 도커 호스트의 docker0 가 도커 컨테이너 내부의 eth0 와 통신하게 된다 


### 도커 컨테이너 생성 시 사용하는 네트워크 드라이버 옵션

* docker network ls 입력 시 bridge, host, none 세 가지의 네트워크 드라이버 확인 가능

* bridge 드라이버

    - 컨테이너를 생성할 때 사용하는 기본 드라이버 (기본 옵션)

    - 각 컨테이너는 각자의 네트워크 인터페이스를 가진다

    - 이는 도커 호스트의 docker0 과 연결됨

* host 드라이버

    - 컨테이너 생성 시 자체적으로 네트워크 인터페이스를 가지지 않고 호스트 네트워크 인터페이스를 공유

    - 컨테이너 실행 명령어에 --network=host 사용

* none 드라이버

    - 컨테이너 생성 시 네트워크 인터페이스를 가지지 않아 외부와 통신이 불가능함

### 도커 호스트 <-> 컨테이너 파일 전송

* 도커 호스트 -> 컨테이너

    - 도커 호스트에 txt 파일 생성

    - docker container cp [출발 경로/보내고 싶은 파일명] [도착 컨테이너:파일 저장 경로] 입력

        - 예시) docker container cp ./test01.txt 5107fcf5ef1d:/home

        - 도커 컨테이너의 home 디렉토리에 test01.txt 파일이 복사됨

* 컨테이너 -> 도커 호스트

    - 도커 컨테이너에 txt 파일 팽성

    - 도커 호스트에 docker cp [출발 경로/보내고 싶은 파일명] [도착 컨테이너:파일 저장 경로] 입력 

        - 도커 컨테이너에는 도커가 설치되어 있지 않으므로 도커 관련 명령어 입력 불가능

        - 그래서 도커 호스트에서 명령어를 입력해 컨테이너에서 파일을 복사해온다

### 도커 스토리지

* 도커 컨테이너에서 생성되는 데이터를 보존하기 위한 공간

* 도커 컨테이너에서 생성되는 데이터를 컨테이너 삭제 후에도 유지될 수 있도록 해주는 역할을 한다

* volume, bind mount, tmpfs 의 3가지 종류가 있다

* volume

    - 도커가 관리하는 전용 디렉토리에(volume) 와 컨테이너의 디렉토리를 연결

    - 컨테이너에서 생성된 데이터는 연결된 도커 전용 디렉토리 내부에 저장됨

* bind mount

    - 호스트 OS의 실제 디렉토리와 컨테이너 내부의 디렉토리를 연결

    - 컨테이너에서 생성된 데이터는 연결된 호스트 OS의 실제 디렉토리 내부에 저장된다

    - 반대로 호스트 OS에서 생긴 변경사항도 연결된 컨테이너 디렉토리에 반영된다

* tmpfs Mount

    - 메모리 상에만 존재하는 임시 저장소

    - 컨테이너가 정지되거나 종료되면  데이터가 사라진다

    - 임시 정보나 중요한 정보를 저장할 때 사용
