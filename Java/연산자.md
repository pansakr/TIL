### 배열
 
* 동일한 자료형의 타입으로 메모리에 여러 공간을 생성하여 하나의 변수에 담은것
```
/// 배열 생성 방법 1번
int[] a = new int[3]; //int형 데이터타입이 들어갈 4바이트 메모리 공간 3개 확보

a[0] = 10, a[1] = 20; a[2]= 20; //인덱스에 데이터 저장
```
```
/// 배열 생성 방법 2번
int[] a = {10,20,30}; //new 키워드를 사용하지 않았지만 실행시 자동으로 입력되어 컴파일됨
```

### new 키워드

* 메모리에 데이터를 저장할 공간을 할당받고 그 공간의 참조값을 반환한다.


### 배열의 길이

* 메모리에 몇개의 공간을 생성했는가.
* 배열명.lenght 


### 인덱스

* 배열의 번호. 0부터 시작한다.

* 배열의 길이가 3이면 인덱스는 0,1,2 3개 이다.
```
배열명[인덱스 번호]
```
* 해당하는 인덱스의 배열 값을 가져온다.


### 2차원 배열

```
int[][] a = new int[5][3];
```
* 3의 배열 길이를(현재 길이3) 5번 반복한다(현재 길이15). 3x5 = 15개의 배열 길이가 만들어진다.

```
 a[1] = new int[1];
```

* 2번행의 배열의 칸을 1개로 재할당 


### splite() 메서드

```
String[] split(String regex)
```

* 반환타입은 String 배열로 매개변수에 regex는 구분자이다.

* Split("|")를 하면 |를 기준으로 문자열을 잘라서 배열로 반환하게 된다.

```
String names = "a | b | c | d | e"; 
```

* names.split("|"); 출력 한다면 [a, b, c, d, e] 로 "|"를 기준으로 나뉘어져서 나오게 된다.


### 3차원 배열

* 2차원 배열을 반복해서 만든다.

```
int[][][] b = new int[2][5][3];  // (3칸씩 5줄 표)2개, (3칸씩)5줄, 3칸
```

* 3의 배열길이를(현재 공간3개), 5번 반복하고(현재 공간 15개), 그것을 총 2번 반복해 만든다(현재 공간 30개).


### Arrays 클래스

* toString(Object[] a) 인자로 넘어온 배열의 내용을 문자열로 출력. 1차원 배열만 가능

* deepToString(Object[ ] a) 2차원 이상의 배열의 내용만 출력 가능.

* equals() 내용이 같은지 비교해 true, false 반환. 1차원 배열만 가능

* deepEquals() 위와 같지만, 2차원 이상의 배열만 가능.

* copyOf(복사할 배열이름, 배열이름.lenth) 배열을 처음부터 입력한 길이만큼 복사.

* copyOfRange(복사할 배열이름, 시작위치, 배열이름.lenth) 배열을 시작위치를 정해서 입력한 길이만큼 복사

* sort(배열이름) 배열의 내용을 오름차순으로 정렬

* sort(배열이름, 시작인덱스, 끝인덱스) 배열의 지정범위를 오름차순으로 정렬


### List로 데이터 추가하는 방법

* Arrays.asList("추가할 데이터") 
