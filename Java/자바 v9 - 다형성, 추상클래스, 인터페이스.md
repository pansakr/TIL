### {자료형} {인스턴스명} = new {생성자} 
```
Car car = new Car();
```

* new Car()
 
  - Heap 영역 Car 클래스의 객체(인스턴스)를 생성
 
  - 필드가 있다면 기본값 또는 생성자에서 지정한 값으로 초기화

* Car car

  - 스택 영역에 Car 타입의 참조변수 car 를 생성
 
* = (대입)

  - Heap 에 있는 Car 객체의 주소값을 스택의 car 참조변수에 저장

  - 이제 car 참조변수를 통해 Heap 의 Car 객체에 접근 가능


### 추상 클래스(Abstract Class)

* 공통적인 특성과 기능을 정의하지만, 구체적인 동작은 자식 클래스가 구현하도록 강제하는 클래스

  - 같은 속성을 가진 클래스가 여러개 필요할 때, 보통 표준 클래스 하나를 만들어서 공통적인 멤버 변수와 멤버 메서드를 정의하고 이를 상속받는 방식으로 만든다
 
  - 하지만 상속받는 클래스들에서 서로 다른 내용을 구현해야 할 경우 표준 클래스에 구현체가 없는 메서드만 선언하는데 이를 추상 메서드라고 한다

  - 추상 메서드를 포함하는 클래스를 추상 클래스라고 한며 추상 메서드는 상속받는 클래스에서 반드시 구현해야 한다
 
  - 반드시 추상 메서드가 있어야 하는 건 아니고, 단순히 클래스 앞에 abstract 키워드가 붙으면 추상 클래스가 된다

* 추상 메서드는 선언부 앞에 abstract를 붙여야 하며 이를 포함한 클래에도 abstract를 붙여야 한다

* 추상 클래스는 객체를 직접 생성할 수 없다 (new 로 인스턴스 만들 수 없음)

```java
// 추상 클래스
public abstract class Animal {
    String name;

    // 일반 메서드
    public void eat() {
        System.out.println(name + "가 먹고 있습니다.");
    }

    // 추상 메서드 (구체 구현 없음 → 세미콜론만)
    public abstract void sound();
}

// 자식 클래스 1
public class Dog extends Animal {
    @Override
    public void sound() {
        System.out.println("멍멍!");
    }
}

// 자식 클래스 2
public class Cat extends Animal {
    @Override
    public void sound() {
        System.out.println("야옹~");
    }
}
```


### 다형성(Polymorphism)

* 부모 클래스의 자료형으로 자식 클래스의 인스턴스를 참조하는것

```
부모 클래스 참조변수명 = new 자식클래스 생성자(); 
```

* 부모 클래스에 없는 메서드(자식 클래스에서 새로 만든 메서드)는 사용할 수 없다

* 자식클래스에서 오버라이딩한 메서드는 사용할 수 있다

```
public class A{
    public void aHello(){...}
}

public class B extends A{
    public void bHello(){...}

    // @Override
    // public void aHello(){...}
}

public class Main{
    public static void main(String[] args) {

        A a = new B();
        a.aHello();
    }
}
```

* 변수의 타입

    - 참조 변수가 접근할 수 있는 멤버 변수의 범위

    - 참조 변수 a 는 A 타입이기에 A의 멤버 변수, 메서드만 접근할 수 있다

* 실제 객체 타입

    - new 로 생성된 객체의 타입

    - new B() : Heap 영역에 B 객체가 생성되고 그 안에 부모 정보와 자식 정보가 함께 들어있음 

        - 자식 클래스는 부모 클래스를 상속 받았기 때문에 부모 클래스의 필드/메서드 를 가지고 있음

        - 따라서 자식 클래스의 객체를 생성하면 Heap 에 하나의 자식 객체가 생성되고 그 내부에 자식 클래스의 필드/메서드 영역, 부모 클래스의 필드/메서드 영역이 모두 생성됨 

        - 그리고 부모 타입(a) 참조변수로 자식 객체의 주소를(B) 참조할 수 있는 이유는 Heap 에 생성된 자식 객체에 부모 클래스의 정보가 포함되었기 때문

* 런타임 동작

    - 메서드 실행 시 실제 객체 타입 기준으로 동작

    - a.aHello() -> 참조변수 a의 실제 객체 타입은 B 이고, 따라서 B의 aHello() 가 실행된다

    - 만약 B 에서 aHello() 를 오버라이딩 했다면 오버라이딩한 대로 실행된다


### 인터페이스

* 추상 메서드와 상수만을 가지는 타입

* 한 클래스에서 여러 인터페이스를 구현 할 수 있다

* 구현 클래스는 인터페이스의 모든 추상 메서드를 반드시 구현해야 한다

```
(abstract) interface 인터페이스명{} // 'abstract'는 생략 가능
```
```java
interface MyInterface {

    // public static final 상수
    int MAX = 10;  // 항상 public static final

    // public abstract 메서드
    void doSomething(); // 항상 public abstract

    // (Java 8+) default 메서드 (구현 가능)
    default void defaultMethod() {
        System.out.println("Default implementation");
    }

    // (Java 8+) static 메서드
    static void staticMethod() {
        System.out.println("Static method in interface");
    }
}

```

* 인터페이스의 default 메서드

  - 인터페이스에 메서드를 추가하면 구현한 클래스들에 모두 구현해야하는 번거로움이 있었다
  
  - 인터페이스에 default 키워드가 붙은 메서드를 만들면 구현 클래스들이 반드시 재구현하지 않아도 된다 (구현 여부는 선택사항이 됨)
  
  ```
  (생략된 접근제어자) default int num(int a){}  //접근제어자는 생략되었고, default는 디폴트 메서드임을 알린다
  ```
