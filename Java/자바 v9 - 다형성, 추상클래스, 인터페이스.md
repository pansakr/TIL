### {자료형} {인스턴스명} = new {생성자} 
```
Car car = new Car();
```

* new Car()
 
  - Heap 영역 Car 클래스의 객체(인스턴스)를 생성
 
  - 필드가 있다면 기본값 또는 생성자에서 지정한 값으로 초기화

* Car car

  - 스택 영역에 Car 타입의 참조변수 car 를 생성
 
* = (대입)

  - Heap 에 있는 Car 객체의 주소값을 스택의 car 참조변수에 저장

  - 이제 car 참조변수를 통해 Heap 의 Car 객체에 접근 가능


### 추상 클래스(Abstract Class)

* 공통적인 특성과 기능을 정의하지만, 구체적인 동작은 자식 클래스가 구현하도록 강제하는 클래스

  - 같은 속성을 가진 클래스가 여러개 필요할 때, 보통 표준 클래스 하나를 만들어서 공통적인 멤버 변수와 멤버 메서드를 정의하고 이를 상속받는 방식으로 만든다
 
  - 하지만 상속받는 클래스들에서 서로 다른 내용을 구현해야 할 경우 표준 클래스에 구현체가 없는 메서드만 선언하는데 이를 추상 메서드라고 한다

  - 추상 메서드를 포함하는 클래스를 추상 클래스라고 한며 추상 메서드는 상속받는 클래스에서 반드시 구현해야 한다
 
  - 반드시 추상 메서드가 있어야 하는 건 아니고, 단순히 클래스 앞에 abstract 키워드가 붙으면 추상 클래스가 된다

* 추상 메서드는 선언부 앞에 abstract를 붙여야 하며 이를 포함한 클래에도 abstract를 붙여야 한다

* 추상 클래스는 객체를 직접 생성할 수 없다 (new 로 인스턴스 만들 수 없음)

```java
// 추상 클래스
public abstract class Animal {
    String name;

    // 일반 메서드
    public void eat() {
        System.out.println(name + "가 먹고 있습니다.");
    }

    // 추상 메서드 (구체 구현 없음 → 세미콜론만)
    public abstract void sound();
}

// 자식 클래스 1
public class Dog extends Animal {
    @Override
    public void sound() {
        System.out.println("멍멍!");
    }
}

// 자식 클래스 2
public class Cat extends Animal {
    @Override
    public void sound() {
        System.out.println("야옹~");
    }
}
```


### 다형성(Polymorphism)

* 부모 클래스의 자료형으로 자식 클래스의 인스턴스를 참조하는것

```
부모 클래스 참조변수명 = new 자식클래스 생성자(); 
```

* 부모 클래스에 없는 메서드(자식 클래스에서 새로 만든 메서드)는 사용할 수 없다

* 자식클래스에서 오버라이딩한 메소드는 사용할 수 있다

```
// 다형성 설명
1. A, B 클래스가 있고 B클래스가 A클래스를 상속받을때 new B(); 한다면 heap 메모리에 B와 A가 모두 생성된다

2. A a = new B(); 한다면 참조변수 a는 heap메모리의 A, B 중 A를 바라보게 된다

3. B b = new A(); 는 불가능하다. heap메모리에 A만 로드되고 b가 참조할 B가 없기 때문이다

4. B가 A의 메서드를 오버라이딩하면 A a = new B()에서 a참조변수로 오버라이딩한 메서드를 호출하면 b타입의 오버라이딩한 메서드가 호출된다

5. 이를 동적 바인딩라고 한다

6. A a = new B(); 에서 참조변수 a는 A,B 의 두가지 타입을 가진다

7. new B() 할때 heap 메모리의 한 공간 안에 A, B 두개의 객체가 생기고 a가 그중 하나인 A를 가리키고 있지만 같은 공간에 B 객체도 생성되어 있어서 타입이 두개이다
```

### 인터페이스

* 추상 메소드와 상수만을 가지는 타입

* 한 클래스에서 여러 인터페이스를 구현 할 수 있다

* 구현 클래스는 인터페이스의 모든 추상 메서드를 반드시 구현해야 한다

```
(abstract) interface 인터페이스명{} // 'abstract'는 생략 가능
```
```java
interface MyInterface {

    // public static final 상수
    int MAX = 10;  // 항상 public static final

    // public abstract 메서드
    void doSomething(); // 항상 public abstract

    // (Java 8+) default 메서드 (구현 가능)
    default void defaultMethod() {
        System.out.println("Default implementation");
    }

    // (Java 8+) static 메서드
    static void staticMethod() {
        System.out.println("Static method in interface");
    }
}

```

* 인터페이스의 default 메소드

  - 인터페이스에 메서드를 추가하면 구현한 클래스들에 모두 구현해야하는 번거로움이 있었다
  
  - 인터페이스에 default 키워드가 붙은 메서드를 만들면 구현 클래스들이 반드시 재구현하지 않아도 된다 (구현 여부는 선택사항이 됨)
  
  ```
  (생략된 접근제어자) default int num(int a){}  //접근제어자는 생략되었고, default는 디폴트 메서드임을 알린다
  ```
