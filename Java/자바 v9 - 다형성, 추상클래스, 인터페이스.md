### {자료형} {인스턴스명} = new {생성자} 
```
Car car = new Car();
```

* new Car()
 
 - Heap 영역 Car 클래스의 객체(인스턴스)를 생성
 
 - 필드가 있다면 기본값 또는 생성자에서 지정한 값으로 초기화

* Car car

 - 스택 영역에 Car 타입의 참조변수 car 를 생성
 
* = (대입)

 - Heap 에 있는 Car 객체의 주소값을 스택의 car 참조변수에 저장

 - 이제 car 참조변수를 통해 Heap 의 Car 객체에 접근 가능


### 추상 클래스(Abstract Class)

* 비슷한 속성을 가지고 있는 클래스를 여러개 만들때, 보통 표준이 될 클래스를 하나 만들어서 공통적인 멤버 변수와 멤버 메서드를 미리 구현하고 상속받는다
 
* 하지만 때에 따라 다른 내용을 구현해야 할 경우 구현체가 없는 메서드만 선언하는데 이를 추상 메서드라고 한다

* 추상 메서드를 포함하는 클래스를 추상 클래스라고 한다

* 추상 메서드는 선언부 앞에 abstract를 붙여야 하며 이를 포함한 클래에도 abstract를 붙여야 한다

* 추상 메서드는 상속받는 클래스에서 반드시 구현해야 한다


### 다형성(Polymorphism)

* 부모 클래스의 자료형으로 자식 클래스의 인스턴스를 참조하는것

```
부모 클래스 참조변수명 = new 자식클래스 생성자(); 
```

* 부모 클래스에 없는 메서드(자식 클래스에서 새로 만든 메서드)는 사용할 수 없다

* 자식클래스에서 오버라이딩한 메소드는 사용할 수 있다

```
// 다형성 설명
1. A, B 클래스가 있고 B클래스가 A클래스를 상속받을때 new B(); 한다면 heap 메모리에 B와 A가 모두 생성된다

2. A a = new B(); 한다면 참조변수 a는 heap메모리의 A, B 중 A를 바라보게 된다

3. B b = new A(); 는 불가능하다. heap메모리에 A만 로드되고 b가 참조할 B가 없기 때문이다

4. B가 A의 메서드를 오버라이딩하면 A a = new B()에서 a참조변수로 오버라이딩한 메서드를 호출하면 b타입의 오버라이딩한 메서드가 호출된다

5. 이를 동적 바인딩라고 한다

6. A a = new B(); 에서 참조변수 a는 A,B 의 두가지 타입을 가진다

7. new B() 할때 heap 메모리의 한 공간 안에 A, B 두개의 객체가 생기고 a가 그중 하나인 A를 가리키고 있지만 같은 공간에 B 객체도 생성되어 있어서 타입이 두개이다
```

### 인터페이스

* 추상 메소드와 상수만을 가지는 일종의 추상 클래스

* 한 클래스에서 여러개의 인터페이스 구현을 할 수 있다

```
(abstract) interface 인터페이스명{} // 'abstract'는 생략 가능하다
```


### 인터페이스에서 default 메소드

* 인터페이스에 메소드를 추가하면 이를 구현한 클래스들에도 모두 추가해야하는 번거로움이 있다

* 이때 default 키워드가 붙은 메서드를 만들면 일반 클래스에서 메서드를 만든 것과 같은 효과이기 때문에

* 이 디폴트 메서드를 재구현하지 않아도 된다

* ~default 메서드의 default는 접근제어자가 아니라 디폴트 메서드임을 알리는 키워드이다.~

* 자바 1.8부터는 접근제어자 default의 표기가 package-private 으로 변경되었다

```
(생략된 접근제어자) default int num(int a){}  //접근제어자는 생략되었고, default는 디폴트 메서드임을 알린다
```
 
