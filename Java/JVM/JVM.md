### JVM(Java Virtual Machine)

* 자바 바이트코드를 OS에 맞는 기계어로 실행해주는 추상화된 실행 환경

* OS에 맞는 JDK만 설치하면 JDK가 OS에 맞는 명령어로 변환해준다

* 클래스 로더, 런타임 데이터 영역, 실행 엔진으로 이루어져 있다


### 클래스 로더(Class Loader)

* .class파일들을 jvm의 메모리 영역인 Runtime Data Area 에 배치한다

* 한번에 메모리에 올리지 않고 어플리케이션에서 필요한 경우 동적으로 메모리에 적재한다

* 이 과정은(.class 파일을 jvm 런타임 데이터 영역에 배치하는 과정) 로딩, 링크, 초기화의 3단계로 구성된다

* 로딩 - 클래스 파일을 가져와서 jvm의 메모리에 로드한다

* 링크

  - 검증(Verify) : .class 파일이 JVM 명세에 맞는지 검사

  - 준비(Prepare) : static 변수에 메모리 공간 할당 (기본값으로 초기화)

  - 해결(Resolve) : 심볼릭 참조를 실제 참조로 변경

* 초기화 - static 변수를 코드상 정의된 값으로 초기화, static 블록 실행


### Runtime Data Area

* jvm의 메모리 영역으로, 자바 어플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역

* Method, Heap, Stack, Pc Register, 네이티브 메소드 영역으로 나뉜다


#### Method(Static) 영역

* 저장되는 정보

  - 클래스 정보 (이름, 부모, 인터페이스)         

  - 필드 정보 (이름, 타입, 접근제어자)
 
    - 필드의 값은 메서드 영역에 저장되지 않음. heap 에 저장됨
   
  - 메서드 정보 (시그니처, 접근제어자, 바이트코드)

  - static 변수                                

  - 상수 풀(Constant Pool) 

* 쓰임새

  - new 로 객체 생성 시 JVM은 먼저 메서드 영역의 클래스 정보를 참조해서 이 클래스가 어떤 필드를 가지고 있는지, 각 필드의 타입과 초기값은 무엇인지를 확인하고 Heap에 메모리를 할당함

* jvm 시작시 생성되고 프로그램 종료 시까지 사용된다

* 모든 스레드가 공유


#### Runtime Constant Pool

* Method 영역의 내부에 존재하는 별도의 관리영역

* 클래스들의 상수 정보가 저장된다


#### Heap 영역

* new 키워드로 생성된 객체와 인스턴스 변수, 배열이 저장되는 영역

* 참조되지 않는 객체는 gc가 제거한다

* 모든 스레드가 공유한다


#### Stack 영역

* 메서드 호출시 해당 메서드의 스택 프레임이 생성되는 영역

* 스택 프레임

  - 메서드가 호출될 때마다 하나씩 생성되는 메서드 실행 공간으로 메서드 실행에 필요한 모든 데이터가 담겨있다
 
    - 메서드 실행에 필요한 데이터 : 매개변수, 지역 변수, 중간 계산 값, 메서드 복귀 주소 등
   
  - 후입선출(LIFO) 의 구조를 가짐

  - 구성
 
    - 지역 변수 테이블(Local Variables) : 메서드 매개변수 + 지역 변수 저장. 객체 참조 변수도 여기 들어감
   
      ```
      void test() {
          int x = 10;
          String s = new String("Hello");
      }

      -------------------------------------------------------

      [Stack]
      ┌────────────────────────────┐
      │ test() 스택 프레임          │
      │ ┌────────────────────────┐ │
      │ │ Local Variables         │ │
      │ │ 0: x = 10               │ │ ← 기본 타입 값 직접 저장
      │ │ 1: s = 0x1234           │ │ ← Heap 객체 주소 저장
      │ └────────────────────────┘ │
      │ Operand Stack ...          │
      └────────────────────────────┘
      
      [Heap]
      0x1234 → String 객체("Hello")
      ``` 
   
    - 연산 스택(Operand Stack) :	바이트코드 명령어들이 계산에 사용할 값을 임시로 저장하는 스택. 예: 덧셈, 곱셈 중간 값
   
    - 프레임 데이터(Frame Data) : 현재 실행 중인 메서드에 대한 정보, 예외 처리 정보, 복귀 주소 등

  - 메서드 내부의 기본 타입 변수는 스택 프레임 안의 지역 변수 테이블에 직접 값을 가진다

  - 메서드 내부의 참조타입 변수는 힙 영역이나 메소드 영역의 객체 주소를 가진다
   
  - 메서드별로 독립 공간을 가지며, 실행이 끝나면 삭제된다

  ```
  public class Main {
      public static void main(String[] args) {
          int result = add(3, 5);
          System.out.println(result);
      }
  
      static int add(int a, int b) {
          return a + b;
      }
  }
  ```

  - 실행 흐름

      - main() 호출 → JVM 스택에 main 스택 프레임 생성
      
        - 지역 변수: args
        
        - 연산 스택: 비어있음
      
      - main()에서 add(3, 5) 호출
      
        - 새로운 add 스택 프레임 생성
      
        - 지역 변수: a=3, b=5
        
        - 연산 스택: a+b 계산 값 저장
      
      - add() 종료 → 스택 프레임 제거
      
      - 결과값이 main()의 연산 스택으로 전달
      
      - main() 종료 → 스택 프레임 제거 → 프로그램 종료


* JVM 은 스레드마다 고정 크기의 스택 영역을 할당한다

  - 여기서 스택 영역이란 '스택 프레임 하나의 크기' 가 아닌 JVM 전체 스택 영역에서 하나의 스레드가 사용할 수 있는 영역을 의미함

  - 프로그램 실행 중 하나의 스레드가 사용할 수 있는 스택 공간을 전부 써버렸을 때 StackOverFlowError가 발생한다
 
    - 재귀 호출을 너무 많이 사용한 경우
   
    - 메서드의 지역 변수를 지나치게 많이 선언한 경우 

* 프로세스가 메모리에 로드 될때 스택 사이즈가 고정되어 있어 런타임 시에 스택 사이즈를 바꿀 수 없다

* 쓰레드를 종료하면 스택도 사라진다


#### pc 레지스터

* jvm이 실행할 명령어의 주소를 저장하는 공간

* cpu의 레지스터와 유사한 역할이지만 jvm이 관리한다

* 스레드가 시작될 때마다 각 스레드 별로 생성된다


#### 네이티브 메소드 스택

* 바이트 코드가 아닌 기계어로 작성된 코드를 실행하는 공간

* 다른 언어(C, C++)로 작성된 네이티브 코드를 실행하기 위한 공간이기도 하다

* 메소드 실행중 다른 언어로 인한 JNI가 실행되면 네이티브 메소드 스택에 바이트 코드로 전환되어 저장된다

* 스레드가 시작될 때마다 각 스레드 별로 생성된다

*JNI - 자바가 다른 언어로 만들어진 어플리케이션과 상호 작용할 수 있는 인터페이스를 제공하는 프로그램


### 실행 엔진

* 바이트 코드를 명령어 단위로 읽어서 실행한다

* 인터프리터, jit컴파일러, 가비지 콜렉터로 이루어져 있다

* 바이트 코드는 가상머신이 이해할 수 있는 코드이고, 이것을 cpu가 이해할 수 있는 기계어로 변환한다

* 이 과정에서 인터프리터와 jit컴파일러 두 가지 방식을 혼합하여 실행한다


#### 인터프리터(Interpreter)

* 바이트 코드를 명령어 단위로 읽어서 해석하고 바로 실행한다

* jvm안에서 바이트코드는 기본적으로 인터프리터 방식으로 동작한다

* 같은 코드가 여러번 호출되어도 매번 해석하고 수행하기 때문에 전체적인 속도는 느리다


#### jit 컴파일러(Just In Time Compiler)

* 인터프리터의 단점을 보완하기 위해 도입, 반복되는 코드를 찾아 전체를 컴파일해 기계어로 변환하고 캐싱해 두었다가 해당 코드가 사용되면 캐싱해 둔 기계어를 직접 실행한다

* 기계어로 컴파일해둔 코드를 실행하는 것이기 때문에 실행 속도는 인터프리팅 방식보다 빠르다

* 하지만 바이트코드를 기계어로 변환해 캐싱해 두는것은 비용이 소모된다

* JVM은 처음에는 바이트코드를 인터프리터 방식으로 실행하다, 반복 호출되는 메서드나 루프 등을 감지하면 JIT 컴파일러가 해당 코드를 기계어로 컴파일하여 성능을 최적화한다

* 한번만 실행되는 코드는 인터프리팅이 유리하다

#### 가비지 콜렉터(Garbage Collector)

* Heap 메모리 영역에서 사용하지 않는 메모리(참조되지 않은 객체)를 자동으로 회수 해준다

* java는 이 가비지 컬렉터를 이용해 자동으로 메모리를 실시간 최적화 시켜준다

### 자바 프로그램을 모든 os에서 실행할 수 있는 이유

* 윈도우용 프로그램은 다른 os에서 실행이 불가능 -> os 명령어가 다르기 때문 

* 자바 프로그램은 모든 os에서 실행 가능

* os에 맞는 자바를 설치하면 .java -> .class 로 컴파일 된 자바 파일을 os에 맞는 명령어로 바꿔 실행한다

* 개발할 때와 서버에서 실행할 때 다른 자바 사용 가능

* 개발 - 윈도우 or 맥 (오라클 jdk), 서버 - 리눅스 (아마존 jdk) 로 서로 다른 자바를 사용해도 문제없다

* 자바는 운영체제의 독립성을 가지고 있다
