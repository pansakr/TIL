### 자바 컴파일러 

* jdk를 설치하면 bin 폴더에 존재하는 javac.exe 실행파일
* 자바 소스 코드(.java)파일을 자바 바이트 코드(.class)파일로 변환시킨다

### 자바 바이트코드  

* 자바 가상 머신(jvm)이 이해할 수 있는 이진 코드로 변환된 자바 소스 코드. 확장자는 .class

### 컴파일 

* 고급언어를 기계어로 번역하는것

### 컴파일러 

* 컴파일하는 프로그램


### JVM(Java Virtual Machine)

* 자바를 OS에 의존적이지 않게 실행 할수 있게 하는 가상 cpu.

* OS에 맞는 JDK만 설치하면 JDK가 OS에 맞는 명령어로 변환해준다.

* 클래스 로더, 런타임 데이터 영역, 실행 엔진으로 이루어져 있다.


### 클래스 로더(Class Loader)

* .class파일들을 jvm의 메모리 영역인 Runtime Data Area 에 배치한다.

* 한번에 메모리에 올리지 않고 어플리케이션에서 필요한 경우 동적으로 메모리에 적재한다.

* 이 과정은 로딩, 링크, 초기화의 3단계로 구성된다.

* 로딩 - 클래스 파일을 가져와서 jvm의 메모리에 로드한다.

* 링크 - 가져온 파일이 jvm명세대로 구성되있는지 검사하고 필요로 하는 메모리를 할당한다.

* 초기화 - 클래스 변수들을 설정된 값으로 초기화한다.


### Runtime Data Area

* jvm의 메모리 영역으로 자바 어플리케이션을 실해할 때 사용되는 데이터들을 적재하는 영역

* Method, Heap, Stack, Pc Register, 네이티브 메소드 영역으로 나뉜다.


#### Method 영역

* static 메소드, 변수 등을 저장한다.

* static 메서드 내부에 static 변수는 만들지 못한다.

* static 영역에 메서드 이름만 올려져 있다가 해당 메서드 호출 시 스택 프레임에 공간이 생성되고 내부를 오픈해 해당 메서드 queue에 내부 실행 코드가 차례대로 쌓여 실행되는데 이때 static 키워드를 만난다면 method 영역에 할당하지 못한다.

* method 영역 할당은 main 실행 전으로 제한되어 있고, 메서드는 호출 전까지 내부를 오픈할 수 없기 때문에 내부의 static 변수를 method 영역에 main 실행 전 할당하지 못한다.

* jvm 시작시 생성되고 프로그램 종료 시까지 사용된다.

* 모든 스레드가 공유한다.


#### Runtime Constant Pool

* Method 영역의 내부에 존재하는 별도의 관리영역

* 클래스들의 상수 정보가 저장된다.


#### Heap 영역

* new 키워드로 생성된 객체와 인스턴스변수, 배열이 생성되는 영역

* 참조되지 않는 객체는 gc가 제거한다.

* 모든 스레드가 공유한다


#### Stack 영역

* 메서드 호출시 해당 메서드의 임시 저장 공간이 생성되는 영역

* 메소드가 호출될 때 각각의 스택 프레임이 생성된다. 각 스택 프레임은 하나의 메소드에 대한 상태 정보를 저장한다.

* 스택 프레임에는 메서드의 메개변수, 지역변수, 리턴값, 연산시 결과값 등을 임시로 저장한다.

* 메서드 실행이 끝나면 해당 메서드가 할당받은 공간은 삭제된다.

* 메서드 내부의 기본 타입 변수는 스택 영역에 직접 값을 가진다.

* 메서드 내부의 참조타입 변수는 힙 영역이나 메소드 영역의 객체 주소를 가진다.

* 스택 영역은 각 스레드마다 하나씩 존재하며, 스레드가 시작될 때 할당된다.

* 프로세스가 메모리에 로드 될때 스택 사이즈가 고정되어 있어 런타임 시에 스택 사이즈를 바꿀 수 없다.

* 고정된 크기의 jvm스택에서 프로그램 실행 중 메모리 크기가 충분하지 않다면 StackOverFlowError가 발생한다.

* 쓰레드를 종료하면 스택도 사라진다.

*스택 프레임 - 현재 실행중인 메소드의 상태 정보를 저장하는 곳


#### pc 레지스터

* jvm이 실행할 명령어의 주소를 저장하는 공간

* cpu의 레지스터와 유사한 역할이지만 jvm이 관리한다.

* 스레드가 시작될 때마다 각 스레드 별로 생성된다.


#### 네이티브 메소드 스택

* 바이트 코드가 아닌 기계어로 작성된 코드를 실행하는 공간

* 다른 언어(C, C++)로 작성된 네이티브 코드를 실행하기 위한 공간이기도 하다.

* 메소드 실행중 다른 언어로 인한 JNI가 실행되면 네이티브 메소드 스택에 바이트 코드로 전환되어 저장된다.

* 스레드가 시작될 때마다 각 스레드 별로 생성된다.

*JNI - 자바가 다른 언어로 만들어진 어플리케이션과 상호 작용할 수 있는 인터페이스를 제공하는 프로그램


### 실행 엔진

* 바이트 코드를 명령어 단위로 읽어서 실행한다.

* 인터프리터, jit컴파일러, 가비지 콜렉터로 이루어져 있다.

* 바이트 코드는 가상머신이 이해할 수 있는 코드이고, 이것을 cpu가 이해할 수 있는 기계어로 변환한다.

* 이 과정에서 인터프리터와 jit컴파일러 두 가지 방식을 혼합하여 실행한다.


#### 인터프리터(Interpreter)

* 바이트 코드를 명령어 단위로 읽어서 해석하고 바로 실행한다.

* jvm안에서 바이트코드는 기본적으로 인터프리터 방식으로 동작한다.

* 같은 코드가 여러번 호출되어도 매번 해석하고 수행하기 때문에 전체적인 속도는 느리다.


#### jit 컴파일러(Just In Time Compiler)

* 인터프리터의 단점을 보완하기 위해 도입, 반복되는 코드를 찾아 전체를 컴파일해 기계어로 변환하고 캐싱해 두었다가 해당 코드가 사용되면 캐싱해 둔 기계어를 직접 실행한다.

* 기계어로 컴파일해둔 코드를 실행하는 것이기 때문에 실행 속도는 인터프리팅 방식보다 빠르다.

* 하지만 바이트코드를 기계어로 변환해 캐싱해 두는것은 비용이 소모된다.

* 그래서 jvm은 기본적으로 인터프리팅 방식을 사용하다 일정 기준이 넘어가면 jit 컴파일 뱡식으로 명령어를 실행한다.

* 한번만 실행되는 코드는 인터프리팅이 유리하다

#### 가비지 콜렉터(Garbage Collector)

* Heal 메모리 영역에서 사용하지 않는 메모리(참조되지 않은 객체)를 자동으로 회수 해준다.

* java는 이 가비지 컬렉터를 이용해 자동으로 메모리를 실시간 최적화 시켜준다.



### jvm 실행 과정

* 자바 프로그램을 실행하면 jvm은 os로부터 메모리를 할당받는다.

* 자바 컴파일러가 .java파일(작성한 소스코드)을 .class(바이트 코드)로 컴파일 한다.

* Class Loader는 동적 로딩을 통해 필요한 클래스(.class로 변환된 바이트 코드)들을 Runtime Data Area에 올린다.

* Runtime Data Area에 로딩된 바이트 코드는 Execution Engine을 통해 해석된다.

* 이 과정에서 Execution Engine에 의해 Garbage Collector의 작동과 Thread 동기화가 이루어진다.


### 자바 프로그램을 모든 os에서 실행할 수 있는 이유

* 윈도우용 프로그램은 다른 os에서 실행이 불가능 -> os 명령어가 다르기 때문 

* 자바 프로그램은 모든 os에서 실행 가능

* os에 맞는 자바를 설치하면 .java -> .class 로 컴파일 된 자바 파일을 os에 맞는 명령어로 바꿔 실행한다

* 개발할 때와 서버에서 실행할 때 다른 자바 사용 가능

* 개발 - 윈도우 or 맥 (오라클 jdk), 서버 - 리눅스 (아마존 jdk) 로 서로 다른 자바를 사용해도 문제없다

* 자바는 운영체제의 독립성을 가지고 있다


### 동기 프로그래밍

* 프로그래밍에서의 동기 - 일의 순서

* 데이터에서의 동기 - 데이터의 일치여부
