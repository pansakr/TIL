### 연속 메모리 할당

* 프로세스에 연속적인 메모리 공간을 할당하는 방법

* 메모리에 적재된 프로세스들 중 오랫동안 실행되지 않는 프로세스가 있다면 스와핑을 한다

* 스와핑

    - 오래 사용되지 않은 프로세스를 임시로 보조기억장치 일부 영역으로 보내고, 그렇게 생긴 빈 공간에 다른 프로세스를 적재하여 실행하는 방식

    - 프로세스들이 보내지는 보조기억장치의 일부 영역을 '스왑 영역'이라고 한다

    - 오래 사용되지 않은 프로세스가 메몰에서 스왑 영역으로 옮겨지는 것을 '스왑 아웃', 반대로 스왑 영역에 있던 프로세스가 다시 메모리로 옮겨지는 것을 '스왑 인' 이라고 한다

    - 스왑 아웃 되었던 프로세스가 스왑 인 될때 이전과 다른 주소에 적재될 수 있다

    - 이 방법으로 프로세스들이 요구하는 메모리 주소 공간의 크기가 실제 메모리 크기보다 커도 동시 실행할 수 있다

### 메모리 할당

* 프로세스를 메모리 내의 빈 공간에 배치할때 여러 방법을 사용한다

* 최초 적합

    - 운영체제가 메모리 내의 빈 공간을 순서대로 검색하다가 적재할 수 있는 공간 발견 시 배치하는 방식

* 최적 적합

    - 운영체제가 빈 공간을 모두 검색한 후 프로세스가 적재될 수 있는 공간 중 가장 작은 공간에 배치하는 방식

* 최악 적합

    - 운영체제가 빈 공간을 모두 검색한 후 프로세스가 적재될 수 있는 공간 중 가장 큰 공간에 배치하는 방식

### 외부 단편화

* 프로세스를 할당하기 어려울 만큼 작은 메모리 공간들로 인해 메모리가 낭비되는 현상

* 연속 메모리 할당 시 외부 단편화가 발생한다

    - 100MB 메모리에 50MB, 10MB, 20MB, 30MB 크기의 프로세스들이 순서대로 배치됬다고 가정한다

    - 10MB, 30MB 크기의 프로세스들이 작업을 마치고 메모리에서 제거하면 남은 공간 크기의 총 합은 40MB 이다

    - 그러나 이 공간들은 서로 떨어져 있기 때문에 40MB 크기의 프로세스를 적재할 수 없다

* 이를 압축으로 해결할 수 있지만 잘 사용하지 않는다

    - 메모리에 여기저기 흩어져 있는 빈 공간들을 하나로 모으는 방식

    - 프로세스들을 재배치시켜 흩어져 있는 작은 빈 공간들을 큰 빈 공간으로 만든다

    - 하지만 빈 공간들을 모으는 동안 하던 일을 중지해야 하고, 많은 부하가 걸리며 어떤 프로세스를 어떻게 움직여야 하는지 명확한 방법을 결정하기 어렵다

* 가상 메모리 관리 기법의 페이징을 사용해 외부 단편화 문제를 해결한다

### 가상 메모리

* 실행하려는 프로그램을 일부만 메모리에 적재해서 실제 물리 메모리 크기보다 큰 프로세스를 실행할 수 있기 하는 기술

* 페이징과 세그멘테이션이 있고 대부분의 운영체제는 페이징을 사용한다

* 페이징

    - 프로세스의 논리 주소 공간을 '페이지' 라는 일정한 단위로 자르고, 메모리 물리 주소 공간을 '프레임' 이라는 페이지와 동일한 크기로 자른 뒤 페이지를 프레임에 할당하는 가상 메모리 관리 기법

    - 페이징에서도 스와핑을 사용할 수 있으며, 페이지 단위로 스왑 아웃/인 된다

        - 페이징에서 스왑 인을 '페이지 인', 스왑 아웃을 '스왑 아웃' 이라고 한다

    - 페이징을 사용해 프로세스를 나누고, 그중 실행에 필요한 일부 페이지만 메모리해 적재하고, 나머지는 보조기억장치에 남겨둠으로서 물리 메모리보다 큰 프로세스를 실행할 수 있다

    - 내부 단편화

        - 페이지 크기보다 작게 잘린 프로세스로 인해 메모리가 낭비되는 현상

        - 하지만 모든 프로세스가 페이지 크기에 딱 맞게 잘리는 것은 아니어서 페이지 크기보다 작게 잘린 프로세스를 프레임에 할당할 시 남는 프레임 공간이 생기고 이를 '내부 단편화' 라고 한다

* 페이지 테이블

    - 페이지 번호와 프레임 번호를 연결한 정보가 있는 테이블

    - 프로세스가 페이징 과정에서 불연속적으로 메모리에 배치되면 cpu는 다음에 실행할 명령어 위치를 찾기 어려워진다

    - cpu가 사용하는 논리 주소 공간의 페이지와 실제 메모리 공간인 프레임을 연결한 페이지 테이블을 사용하면 cpu는 논리 주소를 순차적으로 호출하면 명령을 순차적으로 실행할 수 있다 

        - A 프로세스가 물리 주소 공간에 불규칙적으로 적재되어 있어도 논리 주소의 페이지만 순서대로 되어 있으면 cpu가 논리 주소 순서대로 호출했을때 페이지 테이블로 인해 해당 페이지가 실제로 저장되어 있는 프레임으로 접근할 수 있다 
    
    <img src="https://raw.githubusercontent.com/pansakr/TIL/refs/heads/main/%EC%9D%B4%EB%AF%B8%EC%A7%80/Computer%20Science/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%98%20%EA%B5%AC%EC%84%B1%2C%20%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%ED%8E%98%EC%9D%B4%EC%A7%80%20%ED%85%8C%EC%9D%B4%EB%B8%94.jpg" alt="페이지 테이블">

    - 프로세스마다 각자의 페이지 테이블을 가지고 있고, 페이지 테이블들은 메모리에 적재되어 있다

    - 그리고 cpu 내의 페이지 테이블 베이스 레지스터는 각 프로세스의 페이지 테이블이 적재된 주소를 가리키고 있다

    - 프로세스가 실행될 때 cpu는 페이지 테이블 베이스 레지스터를 통해 페이지가 적재된 프레임을 알 수 있다

    - 하지만 이 방법은 cpu가 페이지 테이블을 보고, 그렇게 알게된 프레임에 접근하는 두 번의 메모리 접근이 필요해서 cpu 곁에 TLB 라는 페이지 테이블의 캐시 메모리를 둔다

    - TLB는 페이지 테이블의 일부 내용을 저장해 두고, cpu는 이를 사용한다
