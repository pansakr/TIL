### Layer와 Layered 구조

* 어떤 설계, 관계에 대한 계층 구조가 있을때 윗 계층은 아래 계층에 의존적이다.

### Osi 7Layer

* 통신 과정을 7단계로 나눈것, 상위 계층은 하위 계층에 의존적이다.

### L1 - Physical Layer 

* 물리적으로 연결된 전선으로 비트 단위의 데이터를 전송하는 계층

* 비트 데이터를 아날로그 신호로 바꾸어(인코딩) 전선으로 흘려보내고, 아날로그 신호가 들어오면 비트 데이터로 해석한다.


### L2 - DataLink Layer 이더넷 프로토콜

* LAN 범위 내에서 Mac 주소를 기반으로 데이터를 전송하는 계층

* 데이터 링크 계층에서 사용하는 데이터 전송 단위는 프레임이다

* Mac주소는 Nic의 식별자다.

*식별자 - 어떤 대상을 유일하게 구분할 수 있는 이름


### L3 - Network Layer 인터넷 프로토콜

* LAN 외부의 네트워크에서 통신하기 위한 계층
  
* ip주소와 라우터를 이용해 전송 경로를 찾고 데이터를 전송한다

* 데이터의 헤더에 있는 목적지 정보(IP주소)를 읽고 경로를 찾는다.

* 세그먼트를 패킷으로 박싱, 언박싱 해주고 이때 목적지 ip주소를 헤더에 집어넣는다


### L4 - Transport Layer TCP, UDP 프로토콜

* port 번호를 통해 데이터를 프로세스에게 전달하는 계층

* 스트림 데이터를 세그먼트로 나눠주거나 세그먼트로 나뉜 데이터를 스트림으로 합쳐주고 출발지와 목적지 포트정보를 집어넣거나 읽는다


### L5 ~ L7 - Application

* 현대의 인터넷은 OSI 7 모델이 아니라 TCP/IP 모델을 사용한다.

* OSI 7 모델은 5,6,7 계층이 각각 Session, Presentation, Application 이지만, TCP/IP는 5,6,7 계층이 Application 하나로 합쳐져 있다

* 응용 계층의 여러 프로토콜을 통해 데이터를 송, 수신하는 계층

* 웹 사이트는 HTTP , 파일전송은 FTP, 메일전송은 SMTP, 메일수신은 POP3 프로토콜을 사용한다.

* 보내는 데이터에 상태 코드나 데이터 형식같은 정보를 추가로 보내고 받는다.

* HTTP는 무상태성이고 따라서 클라이언트와 서버가 상호작용에 필요한 정보를 기억해야할 필요가 있었다.

* 이것을 클라이언트에서 쿠키로 구현하고 서버는 세션으로 구현했다.

### 계층별 데이터 단위

* L1,L2 - Frame

* L3 - Packet. 최대 단위 - MSS(Maxiam Transmission Unit)

* L4 - TCP : Segment, UDP : 데이터그램. 최대 단위 - MSS(Maxiam Segment Size)

* L5 - Stream. 데이터 덩어리 - 보낼 데이터를 일정 크기로 자른것(크기는 프로그래머가 설정). 자른 송신 데이터들을 전부 보내야 스트림이 끝난다


### 소켓

* 커널모드의 프로토콜을 유저모드의 어플리케이션이 접근할 수 있도록 추상화한 인터페이스

### 패킷의 전달

* 프로세스가 소켓에 데이터를 send한다. 

* Stream의 데이터를 세그먼트나 포켓의 최대 단위에 맞게 자른다.

* 커널모드 L4계층의 tcp가 tcp헤더를 붙이고 페이로드에 data를 담는다.(L4 데이터 단위는 Segment)

* 커널모드 L3계층의 ip가 tcp헤더 앞에 ip헤더를 붙인다.

* 커널모드 L2계층의 이더넷이 Fream헤더를 붙인다.

* 이후 L2스위치 -> L3스위치(라우터) 순서로 전송된다. 

* 최종적으로 데이터가 목적지에 도착하면 수신 측에서는 port번호로 데이터를 받아줄 컴퓨터 내부의 장치를 찾는다.

### url에 도메인 네임을 검색시 일어나는 일

* 어플리케이션 계층에서 http request에 필요한 정보들을 담고 이것을 스트림 단위로 자른다.

* tcp계층에서 이것을 mtu단위로 잘라서 세그먼트로 만들고 헤더에 출발,도착 포트번호 정보를 넣어준다.

* ip계층에서 세그먼트를 패킷으로 감싸주고 패킷의 헤더에 출발, 도착 ip 정보를 넣어준다.

* 이때 도착 ip정보를 알아오기 위해 브라우저가 os에게 도메인에 대한 ip주소를 요청하고 os는 저장되있는 도메인 서버에 요청해 받아온다.

* 이더넷 계층에서 패킷으로 프레임으로 감싸주고 헤더에 출발지점의 mac주소, 도착지점에 게이트웨이 mac 주소를 넣어준다.

* 이때 도착 mac 주소를 알기 위해 DHCP서버로부터 받은 게이트웨이 ip주소로 ARP요청을 브로드캐스팅하면 해당 IP주소를 가진 게이트웨이가 MAC정보를 응답한다.

* 첫 요청때 MAC주소를 캐싱하고 이후 요청부터는 캐싱한 데이터를 참고하여 보낸다.

* 프레임을 전송하기 전에 3Way HandShaking으로 송신측과 수신측을 연결한다.

* 이제 프레임이 전송되고 클라이언트의 사설 IP 주소가 공인 IP 주소로 변환된다.

* 여러 라우터들을 거쳐 구글 서버가 연결된 라우터까지 도착하고 패킷에 있는 구글의 ip주소로 arp요청을 브로드캐스팅한다.

* 목적지 구글서버가 arp요청을 받고 mac주소를 응답해준다.

* 응답받은 mac 주소로 패킷이 전달되고 서버는 패킷을 역캡슐화해서 포트를 확인 후 해당 애플리케이션에게 전달한다.

* 애플리케이션이 http request를 받고 적당한 html을 응답해준다.

* 모든 요청과 응답이 끝나면 4Way HandShaking으로 연결을 종료한다.
