### TCP의 한계

* 데이터를 신뢰성 있게 목적지까지 전달하지만 데이터의 내용에는 관여하지 않으며, 그저 패킷을 나눠서 목적지로 보내는 역할만 한다


### 응용 계층(세션 + 표현 + 응용 계층)

* 사용자가 네트워크를 통해 실제로 수행하는 작업(웹 브라우징, 이메일 송수신 등)을 처리하는 계층

* 사용되는 주요 프로토콜로 HTTP/HTTPS, DNS 등이 있다

* DNS

    - 도메인 네임의 관리 체계이자 프로토콜(Domain Name System)

    - 도메인 네임 시스템의 일부인 도메인 이름과 IP 주소 간의 매핑 정보를 저장하고 있는 서버(Domain Name Server)

    - 네트워크상의 어떤 호스트를 특정하기 위해 IP를 사용하는데, 통신하려는 모든 호스트의 IP 주소를 기억하고 있기는 힘들다

    - 그래서 일반적으로 상대 호스트를 특정하기 위해 도메인 네임을 사용한다

        - 도메인 네임이란 호스트의 IP 주소와 대응되는 문자열 형태의 호스트 정보이다

        - ex) www.naver.com, www.google.com 과 같은 문자열

    - 호스트 마다 보유하고 있는 도메인 네임 목록이 담긴 파일도 있다

        - DNS가 전체 도메인 네임을 관리한다면 호스트는 일부 도메인 네임 목록이 담긴 파일을 가지고 있다

        - 호스트마다 개별적으로 보유하는 파일로 파일 이름은 hosts 이다

        - 다만 이런 파일 하나로 네트워크의 모든 도메인 네임, IP 주소 쌍을 기억하기 어렵기 때문에 DNS가 필요하다

    - 도메인 계층

        - 도메인 네임은 .(루트 도메인)을 기준으로 계층적으로 분류된다

        - 최상단에 루트 도메인이 있고, 그 다음 최상위 도메인, 2단계 도메인, 3단계 도메인 순서이다

        - www.google.com
        
            - 루트 도메인은 .이다

                - 원래는 www.google.com. 으로 표기되며 평소에는 .이 생략된 상태이다 

            - 최상위 도메인은 com 이다

                - 대표적으로 com, net, kr, us 등이 있다

            - 하부 도메인인 2단계 도메인은 googole 이다

            - 3단계 도메인은 www 이다

            - 도메인 네임을 모두 포함하는 도메인 네임을 전체 주소 도메인 네임(FQDN - Full Qualified Domain Name) 이라고 한다

                - ex) www.google.com. 은 루트 도메인을 포함한 모든 도메인 네임이 포함되었다  

* URI

    - 자원을 식별할 수 있는 정보

        - TCP/IP 로 서버의 특정 애플리케이션 까지 도달할 수 있지만, 어떤 자원(웹페이지, 파일 등)을 가져와야 할지 알 수 없다

        - URI의 도메인 이름을 DNS 를 통해 IP주소로 변환하여 서버의 위치를 찾고, URL 경로로 서버 내에서 어떤 자원을 요청할지 명확히 지정한다

        - index.html 같은 경로 정보가 있어야 서버 내의 자원을 정확히 요청할 수 있다

        *자원 : 네트워크를 통해 정보를 주고받을 때 송수신하는 대상

            - HTMl파일, 이미지, 동영상, 텍스트 파일 등이 될 수 있다

            - 대부분의 통신은 HTTP를 기반으로 이루어지므로, HTTP 요청 메시지의 대상이라고도  표현한다

        - 어떤 정보를 바탕으로 자원을 식별하느냐에 따라 URL, URN 으로 나뉜다

* URL

    - 위치 기반의 식별자

    - 프로토콜, 도메인 이름, 경로, 쿼리 파라미터로 이루어져 있다

        - http://www.google.com:8080/over/there?name=ferret#nose

        - 첫 부분 http:// 은 scheme 로 '자원에 접근하는 방법'을 의미한다

            - 일반적으로 사용할 프로토콜이 명시되고, HTTP를 사용해 자원에 접근 시 http://, HTTPS 사용 시 https://를 사용한다

        - 두번째 부분 www.google.com 은 authority로 '호스트를 특정할 수 있는 정보'이고 IP 주소나 도메인 네임이 명시되며 : 콜론 뒤에 포트 번호를 붙일 수도 있따

        - 세번째 부분 /over/there 은 path로 '자원이 위치한 경로' 가 명시된다

            - 자원의 위치는 /를 기준으로 계층적으로 표현되고, 최상위 경로 또한 슬래쉬로 표현된다

        - 네번째 부분 ?name=ferret 는 query로, 검색 결과 같은 응답 받으려는 데이터를 위해 필요한 정보를 넘긴다

        - 다섯번째 부분 #nose 는 '자원의 한 조각을 가리키기 위한 정보' html 파일과 같은 자원의 특정 부분을 가리키기 위해 사용된다

* URN

    - 이름 기반 식별자

    - 자원에 고유한 이름을 붙여 자원을 식별한다

    - URN:isbn:0451450523

        - isbn이 0451450523 인 도서를 나타내는 URN 이다

    - 잘 사용하지 않는다

### HTTP

* 응용 계층에서 사용되는 주요 프로토콜

* 요청-응답 기반 프로토콜, 미디어 독립적이며, 상태를 유지하지 않고, 지속 연결을 지원하는 4가지 특성을 가지고 있다

    - 요청-응답 기반 프로토콜

        - 클라이언트와 서버가 데이터를 주고 받는 메커니즘

            - 데이터가 물리적으로 전송되는것은 TCP/IP로 가능한데, 이 데이터들을 언제, 어떻게, 어떤 방식으로 클라이언트와 서버가 주고받을지 규칙을 정해야 한다 

            - 요청-응답 프로토콜이 없다면 클라이언트와 서버가 상호작용할 때 클라이언트가 데이터를 그저 보내기만 하거나, 데이터를 보냈는데 서버가 한참 뒤에 데이터를 보내주거나 하는 등의 일들이 생길 수 있다

            - 클라이언트가 먼저 요청을 보내고, 그에 대한 응답을 서버가 보내는 구조를 정해둠으로써 상호작용의 순서와 타이밍을 보장한다. 이를 통해 클라이언트는 서버에 요청을 보내고 그 결과를 기다리는 명확한 패턴을 따르게 된다

            - 데이터의 전달 방식에 대해서는 TCP/IP 같은 하위 계층에 의존하며, 상호작용의 형태를 정의하는것이 요청-응답 프로토콜이다

    - 미디어 독립적 프로토콜

        - 주고받을 자원의 종류에(미디어 타입) 특별히 제한을 두지 않는 미디어 독립적인 프로토콜

            - HTTP에서 주고받는 자원의 종류를 미디어 타입 또는 MIME 타입이라고 부른다

            - HTTP에서 송수신하는 정보는 미디어 타입으로 나타낼 수 있다

                - 슬래시를 기준으로 타입/서브타입 형식으로 구성된다

                - 타입은 데이터의 유형, 서브타입은 주어진 타입에 대한 세부 유형을 나타낸다
                
                - text/html, text/plain, image/png 차례대로 텍스트 데이터 중 html 문서, 텍스트 데이터 중 일반 텍스트, 이미지 데이터 중 png 이미지 타입을 나타낸다 

                - application/json 은 바이너리 형식의 데이터 중 json 형식 데이터를 뜻한다

    - 상태를 유지하지 않는(stateless) 프로토콜

        - 서버가 HTTP 요청을 보낸 클라이언트와 관련된 상태를 기억하지 않는다는 의미

        - 서버는 클라이언트의 요청을 처리하고 해당 요청과 관련된 정보를 유지하지 않는다

        - 서버는 많은 클라이언트와 동시에 상호작용하므로 동시에 처리해야 할 요청은 매우 많다. 이런 상황에서 모든 클라이언트의 상태 정보를 유지하는 것은 서버에 큰 부담이다

        - tcp가 연결을 유지한다고 해서 http가 상태 정보를 유지하는것은 아니다

            - tcp는 데이터의 전송을 신뢰성 있게 관리할 뿐, 그 데이터의 의미나 상태 관리는 하지 않는다

    - 지속 연결 프로토콜

        - 하나의 tcp 연결상에서 여러 개의 요청-응답을 주고받을 있는 기술

        - tcp는 연결형 프로토콜이고 http는 비연결형 프로토콜이라서 초기에는 tcp 연결 수립 후 요청에 대한 응답을 받으면 tcp 연결을 종료하는 비지속 연결 방식으로 동작했다

        -  최근에는 하나의 tcp 연결상에서 여러 요청-응답을 주고받는 기술을 사용한다

* HTTP 메시지 구조

    - 시작 라인, 필드 라인, 본문으로 이루어져 있다

    ```
    // HTTP 메시지 형태
    
    시작 라인(줄바꿈) 
    필드(헤더) 라인(줄바꿈)    필드 라인은 없거나 여러개 있을수 있다
    (줄바꿈)
    본문                본문은 없을 수도 있다
    ```

    - 시작 라인

        - 요청 메시지일 경우 '요청 라인', 응답 메시지일 경우 '상태 라인' 이 된다

        - 요청 라인

        ```
        // 요청 라인 형태

        메서드(공백)요청 대상(공백)HTTP버전(줄바꿈) 

        GET /example-page HTTP/1.1
        ```

            - 메서드

                - 클라이언트가 서버의 자원에 대해 수행할 작업의 종류

                ```
                // HTTP 메서드 종류

                GET - 자원을 습득하기 위한 메서드
                
                POST - 서버로 하여금 특정 작업을 처리하게끔 하는 메서드
                
                PUT - 자원을 대체하기 위한 메서드
               
                PATCH - 자원에 대한 부분적 수정을 위한 메서드
               
                DELETE - 자원을 삭제하기 위한 메서드
              
                HEAD - GET과 동일하나, 헤더만을 응답받는 메서드
                ```

                - GET
                
                    - 특정 자원을 조회할때 사용되는 메서드

                    - 클라이언트가 서버에게 '이것을 가져다주세요' 라고 요청을 보내는 것과 같다

                    - 헤더에는 요청을 보낼 호스트가(서버) 명시된다 ex) Host: www.naver.com

                - POST

                    - 서버에게 특정 작업을 처리하도록 요청하는 메서드

                    - 클라이언트가 서버에 새로운 자원을 생성하고자 할때 주로 사용된다

                    - 게시판에 글을 작성하고 완료 버튼을 눌렀을 때 POST 메서드가 사용되고 처리할 대상은 메시지 본문으로 명시된다

                - PUT

                    - 덮어쓰기를 요청하는 메서드

                    - 요청 자원이 없다면 본문으로 자원을 새롭게 생성하거나, 이미 자원이 존재한다면 본문으로 자원을 완전히 대체하는 메서드이다

                - PATCH

                    - 부분적 수정을 요청하는 메서드

                    - 서버의 자원이 요청 본문에 맞게 일부분만 수정된다

                - DELETE

                    - 삭제를 요청하는 메서드

                    - 특정 자원을 사용하고 싶을 때 사용한다

                - HEAD

                    - GET과 동일하지만, 응답 메시지에 본문이 포함되지 않는다

                    - 서버는 요청에 대한 응답으로 응답 메시지의 헤더만을 반환한다

                    - 클라이언트가 서버에게 헤더만 달라는 요청을 보내는 것과 같다

            - 요청 대상

                - HTTP 요청을 보낼 서버의 자원의 의미

                - URL의 경로가 명시된다 ex) www.xxx.com/hello?name=gg 에서 /hello?name=gg 가 된다

            - HTTP 버전

                - 사용된 HTTP 버전을 의미한다

                - 표기 방식은 HTTP/<버전> 이며 HTTTP 1.1 버전은 HTTP/1.1 로 표기된다

        - 상태 라인 

        ```
        // 상태 라인 형태

        HTTP버전(공백)상태코드(공백)이유 구문(줄바꿈)

        HTTP/1.1 200 OK
        ```

            - 상태 코드

                - 요청에 대한 결과를 나타내는 세 자리 정수

                ```
                // 상태 코드 종류
                
                100 번대 (100 ~ 199) - 정보성 상태 코드

                200 번대 (200 ~ 299) - 성공 상태 코드

                300 번대 (300 ~ 399) - 리다이렉션 상태 코드

                400 번대 (400 ~ 499) - 클라이언트 에러 상태 코드

                500 번대 (500 ~ 599) - 서버 에러 상태 코드
                ```

                - 200

                    - - 요청이 성공했음을 알려주는 상태 코드
                
                    ```
                    // 200 번대 상태 코드 종류

                    상태 코드  이유 구문  설명 

                    200       Ok         요청이 성공했음

                    201       Created    요청이 성공했으며, 새로운 자원이 생성되었음

                    202       Accepted   요청은 잘 받았으나, 아직 요청한 작업을 끝내지 않았음

                    204       No Content 요청이 성공했지만, 메시지 본문으로 표시할 데이터가 없음
                    ```

                    - 클라이언트로 부터 받은 요청을 성공적으로 받아 처리한 경우 서버는 요청한 자원과 함께 상태 코드 200(ok)를 포함한 응답을 할 수 있다 

                - 300

                    - 리다이렉션과 관련된 상태 코드

                        - 리다이렉션은 클라이언트가 요청한 자원이 다른 곳에 있을때, 클라이언트의 요청을 다른 곳으로 이동시키는 것을 의미한다

                        - 서버는 리다이렉션 응답 메시지의 Location 헤더를 통해 요청한 자원이 위치한 URL을 안내해 준다

                        ```
                        // 리다이렉션 과정

                        // 스프링 부트도 동일한 과정으로 동작한다

                        1. 클라이언트가 A 경로로 요청을 보낸다

                        2. 서버는 A경로에 대한 요청 결과로 리다이렉션 응답(3xx 상태 코드, 예: 302 Found)을 클라이언트에게 보낸다. 이때 응답 헤더에 리다이렉션할 B 경로가 포함된다

                        3. 클라이언트는 이 리다이렉션 응답을 받아 자동으로 B 경로로 다시 요청을 보낸다

                        4. 서버는 B 경로의 요청을 받아 처리하고 그 결과를 클라이언트에게 응답한다
                        ```
                    - 영구적 리다이렉션과 일시적 리다이렉션이 있다

                    - 영구적 리다이렉션

                        - 자원이 완전히 새로운 곳으로 이동하여 경로가 영구적으로 재지정 되는 것을 의미한다

                        - 관련 상태 코드는 301, 308 
                        
                            - 301은 GET이 아닌 요청 메서드를 사용 시 재요청 메서드가 GET으로 변경될 수 있다

                                - 첫 요청에 POST 메서드를 보내고 301을 응답받았다면 두번째 요청에 GET 으로 바뀔 수있다

                            - 308은 재요청 메서드가 변경되지 않는다

                                - 첫 요청에 POST 메서드를 보내고 308을 응답받았다면 두번째 요청도 POST 이다

                        - 이 상태 코드를 응답받았다면 자원의 위치가 영구적으로 변경되었으므로 클라이언트는 요청을 보낸 URL 을 기억할 필요가 없다

                    - 일시적 리다이렉션

                        - 자원의 위치가 임시로 변경되었거나 임시로 사용할 URL이 필요한 경우 주로 사용된다

                        - 관련 상태 코드는 302, 303, 307 이다

                            - 302는 재요청 메서드가 GET 으로 변경될 수 있다

                            - 303은 재요청 메서드가 GET 으로 변경된다

                            - 307은 재요청 메서드가 변경되지 않는다

                - 400

                    - 클라이언트 에러 상태 코드

                    - 서버가 처리할 수 없는 형태로 요청을 보냈거나 존재하지 않는 자원에 대해 요청을 보내는 경우에 속한다

                    ```
                    // 400 번대 상태 코드 종류

                    상태 코드   이유 구문          설명
 
                    400        Bad Request        클라이언트의 요청이 잘못되었음

                    401        Unauthorized       요청한 자원에 대한 유효한 인증이 없음

                    403        Forbidden          요청한 서버에 의해 거부됨(권한이 없을 경우)

                    404        Not Found          요청받은 자원을 찾을 수 없음

                    405        Method Not Allowed 요청한 메서드를 지원하지 않음
                    ```

                    - 400

                        - 요청 메시지의 내용이나 형식에 문제가 있어 서버가 요청을 처리할 수 없는 경우

                    - 401

                        - 특정 자원에 접근하기 위해 인증이 필요한 경우

                    - 403

                        - 자원에 접근할 권한이 없는 경우

                        - 인증이 되었더라도 권한이 없으면 접근하지 못한다

                    - 404

                        - 접근하려고 하는 자원이 존재하지 않을 경우

                    - 405

                        - 서버에 구현되지 않은 메서드로 요청을 보낸 경우

                - 500

                    - 서버 에러 상태 코드

                    ```
                    // 500 번대 에러 종류

                    상태 코드  이유 구문                 설명

                    500       Interner Server Error     요청을 처리할 수 없음

                    502       Bad Gateway               중간 서버의 통신 오류

                    503       Service Unavailable       현재는 요청을 처리할 수 없으나
                                                        추후 가능할 수도 있음
                    ```

                    - 500

                        - 서버의 예기치 못한 상황으로 인해 요청을 처리할 수 없음

                        - 포괄적인 표현으로 서버 내 에러를 통칭한다

                    - 502

                        - 클라이언트와 서버 사이에 위치한 중간 서버의 통신 오류

                        - 클라이언트와 서버는 일반적으로 일대일로 연결되어 통신하지 않고, 사이에 게이트웨이를 비롯한 여러 중간 서버가 존재한다

                        - 클라이언트와 서버가 요청과 응답을 주고받는 과정에서 중간에 위치한 수많은 서버들도 요청과 응답을 주고받게 딘다

                        - 이때 중간에 위치한 중간 서버가 유효하지 않거나 잘못된 응답을 받을 수 있고, 이럴 때 상태 코드 502를 응답한다

                    - 503

                        - 현재 서비스를 일시적으로 이용할 수 없음

                        - 서버가 과부하 상태에 있거나 일시적인 점검 상태일 때 볼 수 있다


            - 이유 구문

                - 상태 코드에 대한 문자열 형태의 설명

                - 상태 코드 200은 '요청이 성공적으로 수행되었음' 을 의미한다 

                - 이유 구문과 함께 표기한 상태 라인은 HTTP 4.1 404 Not Found 이다

    - 필드 라인

    ```
    // 필드 라인 형태

    Host: www.example.com
    User-Agent: Mozilla/5.0 (Window NT 10.0; Win64; x64; rv:109.0) Gecko/20100101
    Firefox/118.0
    Accept: text/html
    ```

        - 0개 이상의 HTTP 헤더가 명시되므로 헤더 라인 이라고도 부른다

            - HTTP 헤더는 HTTP 통신에 필요한 부가 정보를 의미한다

        - 공식 문서에 0개 이상의 HTTP 헤더가 명시된다고 언급하지만, 실제로는 한 HTTP 메시지에 다양한 HTTP 헤더들이 사용된다

    - 본문

    ```
    // 본문 형태

    // json 일 경우
    
    {
        "id" : 12345,
        "name" : "John Doe",
        "email" : "jogndoe@example.com"
    }

    // html 일 경우

    <!DOCTYPE html>
    <html>
    <head>
        ...
    </head>
    <body>
        ...
    </body>
    </html>
    ```

        - HTTP 요청 혹은 응답 메시지에서 본문이 필요한 경우 본문에 명시된다

        - 본문은 필요시 사용되므로 존재하지 않을 수도 있고, 위와 같이 여러 타입이 사용될 수도 있다

### HTTP 헤더

* 요청 시 활용되는 HTTP 헤더

    - Host

        - 요청을 보낼 호스트를(서버측 호스트) 나타내는 헤더

    - User-Agent

        - Http 요청을 시작하는 클라이언트 측의 프로그램

        - 요청 메시지 생성에 관여한 클라이언트 프로그램과 관련된 정보가 명시된다

        - 운영체제, 브라우저 종류 및 버전, 렌더링 엔진 과 같은 정보들이 명시된다

    - Referer

        - 클라이언트가 요청을 보낼 때 머무르고 있던 URL이 명시된다

        - 이 헤더를 보고 서버는 클라이언트가 어떤 URL에서 요청을 보냈는지 알 수 있다

    - Authorization

        - 클라이언트의 인증 정보를 담는 헤더

        ```
        Authorization : <type> <credentials>
        ```

        - 인증 타입과(type) 인증 정보에(credentials) 따라 명시될 값이 달라진다

        - 인증 타입의 종류는 다양하지만 가장 기본적인 HTTP 인증 타입은 basic이라는 타입이다

            - Basic은 username:password 와 같이 사용자 아이디와 비밀번호를 콜론을 이용해 합친 뒤, 이를 Base64 인코딩한 값을 인증 정보로 삼는 방식이다

            - Base64 는 문자를 코드로 변환하는 방법을 의미하는 인코딩 방식의 일종이다

            - 예를 들어 사용자 아이디가 'minchul'이고 비밀번호는 '1234' 라고 한다면 이를 Base64로 인코딩하면 'bWluY2h1bDoxMjM0'이 된다

            - 따라서 'minchul'와 비밀번호'1234' 를 Basic 타입으로 인증하려면 아래와 같은 헤더를 보내면 된다

            ```
            Authorization : Basic bWluY2h1bDoxMjM0
            ```

* 응답 시 활용되는 HTTP 헤더

    - Server

        - 요청을 처리하는 서버 측의 소프트웨어와 관련된 정보를 명시한다

        ```
        Server : Apache/2.4.1 (Unix)
        ```
        
        - 위의 헤더는 Unix 운영체제에서 동작하는 아파치 HTTP 서버 를 의미한다

    - Allow

        - 클라이언트에게 허용된 HTTP 메서드 목록을 알려 주기 위해 사용된다

        - 405(요청한 메서드를 지원하지 않음) 응답 시 Allow 헤더가 함께 사용된다

        ```
        // Allow 헤더 예시

        // POST, OPTIONS 메서드만 사용 가능하다
        Allow: POST, OPTIONS
        ```

    - Retry-After

        - 자원을 사용할 수 있는 날짜 혹은 시각을 나타낸다

        - 503(현재 서비스를 일시적으로 이용할 수 없음) 응답 시 Retry-After 헤더가 함께 사용된다

        ```
        // Retry-After 헤더 예시

        // 2024년 8월 23일 금요일 09시 이후에 사용 가능하다
        Retry-After: Fri, 23 Aug 2024 09:00:00 GMT
        
        // 120초 이후에 사용가능하다
        Retry-After: 120
        ```

    - Location

        - 클라이언트에게 자원의 위치를 알려 주기 위해 사용되는 헤더

        - 리다이렉션이 발생했을때나 새로운 자원이 생성되었을 때 사용된다

    - WWW-Authenticate

        - 자원에 접근하기 위한 인증 방식을 설명하는 헤더

        - 401(요청한 자원에 대한 유효한 인증이 없음) 응답 시 함께 사용된다


* 요청과 응답 모두에서 활용되는 HTTP 헤더

    - Date

        - HTTP 메시지가 생성된 날짜와 시각에 관련된 정보를 담은 헤더

        ```
        // Date 헤더 예시

        Date: Tue, 15 Nov 1994 08:12:31 GMT
        ```

    - Connection

        - 클라이언트의 요청과 응답 간의 연결 방식을 설정하는 헤더

        - 지속 연결을 하거나 종료할 때 사용한다

        ```
        // Connection 헤더 예시

        // 지속 연결 희망
        Connection: keep-alive

        // 지속연결 종료
        Connection: close
        ```

    - Content-Length

        - 본문의 바이트 단위 크기를 나타내는 헤더

        ```
        // Content-Length 헤더 예시

        Content-Length: 100
        ```

    - Content-Type, Content-Language, Content-Encoding

        - 전송하려는 메시지 본문의 표현 방식을 설명하는 헤더

        - 표현 헤더의 일종이라고 부른다

        - Content-Type

            - 메시지 본문에서 사용된 미디어 타입을 담고 있다

            ```
            // Content-Type 헤더 예시

            // 메시지 본문이 HTML 문서 형식이며, 문자 인코딩으로 UTF-8을 사용하고 있다

            Content-Type: text/html; charset=UTF-8
            ```
        - Content-Language

            - 메시지 본문에 사용된 자연어를 명시

            - 어떤 언어로 작성되었는지 Content-Language 를 통해 알 수 있다

            - <언어코드>나 <언어코드>-<국가 코드> 의 형태를 가지고 있다

            ```
            // 언어 코드               // 국가 코드

            언어      언어 코드        국가      국가 코드 

            한국어     ko             한국       KR

            영어       en             미국       US
 
            중국어     zh             중국       CN

            일본어     ja             일본       JP

            독일어     de             독일       DE

            프랑스어   fr             프랑스      FR

                                     영국        GB

                                     타이완      TW
            ```

            - 언어 코드와 국가 코드를 조합해 '어떤 국가에서 사용하는 어떤 언어' 인지 알 수 있다

            - <ko>-<KR> 은 한국에서 사용하는 한국어 라는 의미이다

    - Content-Encoding

        - HTTP를 통해 송수신되는 데이터가 전송 속도를 개선하기 위해 압축이나 변환된 방식이 명시되는 헤더

        - 수신 측은 이 헤더를 통해 압축 및 변환 방식을 인식하고, 압축을 해제하거나 원문으로 재변환하여 본문 내용을 확인할 수 있게 된다


### HTTP 기반 기술

* 캐시

    - 불필요한 대역폭 낭비와 응답 지연을 방지하기 위해 정보의 사본을 임시로 저장하는 기술

        - 동일한 요청에 대해 캐시된 데이터를 활용할 수 있어서 더 빠르게 데이터에 접근할 수 있다

    - 캐시는 웹 브라우저나 클라이언트와 서버 사이에 위치한 중간 서버에 저장된다

    - 원본 데이터가 변경되는 상황에 대비해 캐시된 데이터에 유효 기간을 설정한다

        - 캐시 데이터의 기간이 만료되었다면 원본 데이터를 다시 요청하게 된다

        ```
        // Expires (캐시 만료 날짜), Cache-Control (캐시 만료 시간(초단위))헤더 예시

        // 캐시 데이터의 만료 날짜 또는 유효한 시간을 가리키며 응답 메시지에 포함된다

        // 캐시가 2024년 2월 6일 12:00:00 (GMT 기준) 에 만료됨
        Expires: Tue, 06 Feb 2024 12:00:00 GMT

        // 1200초 (20분) 동안 캐시가 유효함
        Cache-Control: max-age=1200
        ```

* 쿠키

    - 서버에서 생성되어 클라이언트 측에 저장되는 데이터

    - 상태를 유지하지 않는 HTTP의 특성을 보완하기 위한 수단이며 서버가 클라이언트의 상태를 알 수 있게끔 하는 데이터이다

        - 서버는 쿠키를 생성해 클라이언트에게 전송하고, 클라이언트는 전달받은 쿠키를 저장해 두었다가 추후 동일한 서버에 보내는 요청 메시지에 쿠키를 포함해 전송한다

        - 서버는 쿠키 정보를 참고해 두 개의 요청이 같은 클라이언트에서 왔는지, 로그인 상태를 유지하고 있는지 알 수 있다
