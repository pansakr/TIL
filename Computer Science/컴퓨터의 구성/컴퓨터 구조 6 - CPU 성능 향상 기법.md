### CPU 성능 향상 기법

* 클럭

    - 컴퓨터의 모든 부품을 움직일 수 있게 하는 시간 단위

    - 컴퓨터의 모든 부품은 클럭 신호에 맞춰 작동한다

    - 클럭이라는 박자에 맞춰 작동할 뿐 한 박자마다 작동하는 것은 아니다

    - 클럭이 빠를수록 CPU도 빨라지지만 발열도 심해진다

* 헤르츠(Hz)

    - 클럭 속도를 측정하는 단위

    - 1초에 클럭이 몇번 반복되는지 나타낸다

    - 클럭이 1초에 100번 반복되면 CPU의 클럭 속도는 100Hz 이다

    - Base 2.5GHz ~ Max 4.9GHz - 1초에 클럭이 기본적으로 25억번, 순간적으로 최대 49억번 반복

* 코어

    - CPU 내에서 명령어를 실행하는 부품

    - 1코어 : ALT, 레지스터, 제어장치로 이루어진 전통적인 관점의 CPU 1개

    - 기술의 발전에 따라 CPU의 뜻이 전통적인 관점의 CPU -> 전통적인 관점의 CPU를 코어라 부르고, 코어를 여러개 포함하는 부품 

    - 즉 8코어는 명령어를 실행하는 부품(전통적인 관점의 CPU)이 8개 포함된 CPU 이다

    - 코어를 여러개 포함하고 있는 CPU를 멀티코어 CPU 또는 멀티코어 프로세서라 부른다

    - CPU의 연산 속도는 코어 수에 비례하여 증가하진 않는다. 코어마다 처리할 명령어를 얼마나 적절하게 분배하냐에 따라 연산 속도가 크게 달라진다

* 스레드

    - 실행 흐름의 단위. 하드웨어적 스레드와 소프트웨어적 스레드로 나뉜다

    - 하드웨어적 스레드

        - 하나의 코어가 동시에 처리하는 명령어 단위

        - 1스레드 CPU는 한번에 하나, 여러 스레드를 지원하는 CPU는 하나의 코어로 여러개의 명령어를 실행할 수 있다

        - 하나의 코어로 여러 명령어를 처리하는 CPU를 멀티스레드 프로세서 또는 멀티스레드 CPU 라고 한다

        - 8코어 16스레드 CPU : 코어가 8개이고 한번에 열여섯 개의 명령어를 처리할 수 있는 멀티스레드 CPU

        - 8코어 16스레드 CPU는 코어 하나당 두개의 하드웨어 스레드를 처리한다고 볼 수 있다


    - 소프트웨어적 스레드

        - 하나의 프로그램 안에서 독립적으로 실행되는 단위

        - 프로그래밍 언어는 수십개의 소프트웨어적 스레드를 만들 수 있다

        - 1코어 1스레드 CPU도 소프트웨어적 스레드 수십개를 실행할 수 있다


* 멀티스레드 프로세서(하드웨어적 스레드)

    - 프로그램 카운터, 스택 포인터 등 하나의 명령을 처리하기 위해 꼭 필요한 레지스터들을 여러개 가지고 있다

* 명령어 병렬 처리 기법

    - 명령어를 동시에 처리해 CPU를 쉬지 않고 작동시키는 방법

    - 명령어 파이프라이닝, 슈퍼스칼라, 비순차적 명령어 처리가 있다

    - 명령어 파이프라이닝

        - 동시에 여러 개의 명령어를 실행하는 방법

        - 명령어 처리 과정을 보통 인출 -> 해석 -> 실행 -> 저장으로 본다

        - CPU가 이 과정들을 겹치지 않게 동시에 실행하는 것

        <img src ="https://github.com/user-attachments/assets/d30fb02c-f462-40cc-bc92-d903ea0ffe56">

        - 생산 공장과 같이 명령어들을 파이프라인에 넣고 실행한다고 해서 파이프라이닝이라 부른다

        - 하지만 특정 상황에서는 이 방법으로 성능 향상에 실패하는 경우가 있다

        - 데이터 위험

            - 데이터 의존적인 두 명령어를 동시에 실행하려고 할때 제대로 작동하지 않는 것

            - 명령어 1이 특정 값을 더해서 R1에 저장하고, 명령어 2가 R1 과 특정 값을 더해서 저장하는 명령이라면 1이 먼저 수행되어야 2를 수행할 수 있다

            - 따라서 명령어 2는 명령어 1의 데이터에 의존적이다

        - 제어 위험

            - 분기로 인한 프로그램 카운터의 갑작스러운 변화로 진행중이던 작업들이 쓸모없어 지는것

            - 프로그램 카운터는 '현재 실행 중인 명령어의 다음 주소' 로 갱신되는데, 프로그램 실행 흐름이 바뀌어 명령어가 실행되며 프로그램 카운터 값에 갑작스러운 변화가 생기면 미리 처리중이었던 명령어들은 쓸모가 없어진다

            - 이를 위해 분기 예측 이라는 기술을 사용하는데 프로그램이 어디로 분기할지 미리 예측 후 그 주소를 인출하는 기술이다

        - 구조적 위험

            - 명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 ALU, 레지스터 등 cpu 부품을 사용하려고 할때 발생

    - 슈퍼스칼라

        - cpu 내부에 여러개의 명령어 파이프라인을 포함한 구조

        - 1코어  1스레드 cpu도 슈퍼스칼라 cpu가 될 수 있다


    - 비순차적 명령어 처리

        - 순서를 바꿔 실행해도 무방한 명령어를 먼저 실행해 명령어 파이프라인이 멈추는 것을 방지하는 기법

        ```
        1. 명령어 처리 과정은 인출 -> 해석 -> 실행 -> 저장의 단계로 이루어져 있다

        2. 명령어 파이프라인은 이 과정을 겹치지 않게 연속적으로 실행하는 것이다

        3. 그런데 앞의 명령어의 결과에 의존성을 가진 명령어는 앞의 명령어가 저장까지 완료해야 실행할 수 있기 때문에 대기해야 한다
        
        4. 그렇게 되면 뒤의 명령어들도 똑같이 대기해야 하는 것이고, 연속적으로 실행하는 명령어 파이프라이닝이 잠시 멈추는 거나 다름없게 되는 것이다

        5. 이를 방지하기 의존성을 가진 명령어가 순서를 바꿔도 문제없다면 뒤로 미뤄 파이프라인이 멈추는 것을 방지하는 비순차적 명령어 처리 기법을 사용한다
        ```

* CISC와 RISC

    - ISA

        - CPU가 이해할 수 있는 명령어들의 모음

        - 명령어마다 생김새, 할 수 있는 연산, 주소 지정 방식 등이 조금씩 다르다

        - 각 제조사들의 CPU마다 이해할 수 있는 명령어(ISA)가 다르다

        - 이해할 수 있는 명령어가 달라지면 어셈블리어도 달라진다

    - CISC

        - 복잡하고 다양한 명령어들은 활용하는 CPU 설계 방식

        - 적은 수의 명령으로도 프로그램을 동작시키고 메모리를 절약할 수 있다

        - 하지만 명령어의 규격화가 어려워 파이프라이닝이 어렵다

            - 각 단계에 소요되는 클럭이 동일해야 파이프라인이 효율적으로 결과를 내는데 CISC는 명령어의 수행 시간이 가지각색이라 파이프라이닝이 어렵다

        - 대다수의 복잡한 명령어는 사용 빈도가 낮아 결국 자주 쓰는 명령어만 사용한다

    - RISC

        - 단순하고 적은 길이의 고정 길이 명령어 집합을 활용하는 CPU 설계 방식

        - 명령어가 규격화되어 있고, 하나의 명령어가 1클럭 내외로 실행되어 파이프라이닝에 최적화되어 있다
