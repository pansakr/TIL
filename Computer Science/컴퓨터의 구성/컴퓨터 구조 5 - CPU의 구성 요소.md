### CPU의 구성 요소

### ALU

* 계산하는 장치

* ALU 가 받는 정보

    - 레지스터로부터 피연산자를 받고, 제어장치로부터 수행할 연산을 알려주는 제어 신호를
    받는다

* ALU 가 내보내는 정보

    - 연산 결과 
    
    - 연산 결과에 대한 추가적인 상태 정보 (플래그)
    
* 연산 결과는 바로 메모리에 저장되지 않고 일시적으로 레지스터에 저장된다

* cpu가 메모리에 접근하는 속도는 레지스터에 접근하는 속도보다 느리기에 매번 메모리에 저장한다면 프로그램의 속도가 느려질 것이다


* 플래그

    - ALU 가 내보내는 연산 결과에 대한 추가적인 정보

    - 부호 플래그 : 연산한 결과의 부호를 나타낸다. 부호 플래그가 1이면 음수, 0이면 양수

    - 제로 플래그 : 연산 결과가 0인지 여부

    - 오버플로우 플래그 : 오버플로우가 발생했는지 나타낸다 

    *오버플러우 - 연산 결과가 연산 결과를 담을 레지스터보다 클때

* ALU 가 내보낸 플래그 정보는 플래그 레지스터에 저장된다

* ALU 내부에는 덧셈, 뺄셈 등 계산을 위한 여러 회로가 있다


### 제어장치

* 제어 신호를 내보내고 명령어를 해석하는 부품

* 제어 신호는 컴퓨터 부품들을 관리하고 작동시키기 위한 전기 신호

* 제어장치가 받는 정보

    - 명령어가 저장된 명령어 레지스터로부터 해석할 명령어

    - 플래그 레지스터로부터 플래그 값

    - 시스템 버스의 제어 버스로 전달된 제어 신호(입출력 장치가 발생시킨 제어 신호)

* 제어장치가 내보내는 정보

    - cpu 외부 : 메모리에 저장된 값을 읽거나 새로운 값을 쓸때 메모리로 제어 신호

    - cpu 외부 : 입출력장치의 값을 읽거나 새로운 값을 쓸때 입출력장치로 제어 신호

    - cpu 내부 : ALU에 수행할 연산을 지시하기 위해

    - cpu 내부 : 레지스터 간에 데이터를 이동시키거나 해석하기 위해 


### 레지스터

* 프로그램 속 명령어와 데이터를 일시적으로 저장하고 처리하는 고속의 작은 기억장치 

* 공통으로 포함하는 여덞개의 레지스터를 제외하면 cpu 제조사들마다 레지스터가 다르다

* 프로그램 카운터(명령어 포인터)

    - 메모리에서 가져올 명령어의 주소를 저장

* 명령어 레지스터

    - 메모리에서 읽은 명령어를 저장

    - 제어 장치는 명령어 레지스터의 명령어를 받아들여 해석 후 제어 신호를 보낸다

* 메모리 주소 레지스터

    - 메모리의 주소를 저장

    - cpu가 읽고자 하는 주소 값을 주소 버스로 보낼때 거친다

* 메모리 버퍼 레지스터

    - 메모리와 주고받을 값(데이터와 명령어)을 저장

    - 메모리에 쓰고 싶은 값이나 메모리로부터 전달받은 값은 메모리 버퍼 레지스터를 거친다

```
// 명령어 사이클. 1 ~ 5 는 인출 사이클, 6 은 실행 사이클
// cpu로 실행할 프로그램이 메모리의 1000번지 ~ 1500번지까지 저장되어있고, 1000번지에는 1101₍₂₎ 이 저장되어 있다고 가정

1. 프로그램을 처음부터 실행하기 위해 프로그램 카운터에 1000이 저장(메모리에서 가져올 명령어의 주소)

2. 1000번지를 읽기 위해 주소 버스로 1000번지를 보내야 하는데, 이를 위해서 메모리 주소 레지스터에 1000 저장

3. '메모리 읽기' 제어 신호와 메모리 주소 레지스터 값이 제어 버스와 주소 버스를 통해 메모리로 보내짐

4. 메모리 1000번지에 저장된 값은 데이터 버스를 통해 메모리 버퍼 레지스터로 전달되고, 프로그램 카운터는 증가되어 다음 명령어를 일거 들일 준비를 한다 (프로그램 카운터 1001)

5. 메모리 버퍼 레지스터에 저장된 값은 명령어 레지스터로 이동

6. 제어장치는 명령어 레지스터의 명령어를 해석하고 제어 신호를 발생시킴

7. 증가된 프로그램 카운터의 값(메모리 1001번지) 을 읽어들임 (반복)
```

* 범용 레지스터

    - 자유롭게 사용할 수 있는 레지스터

    - 메모리 버퍼, 주소 레지스터와 달리 데이터와 주소를 모두 저장할 수 있다

    - 일반적으로 cpu 안에는 여러 개의 범용 레지스터들이 있다

* 플래그 레지스터

    - 연산 결과 또는 CPU 상태에 따른 부가적인 정보를 저장

* 스택 포인터

    - 스택의 꼭대기를(마지막으로 저장한 값의 위치) 가리키는 레지스터

    - 스택에 데이터를 빼거나 더해서 변동 사항이 있어도 항상 제일 위의 값을 가리킨다

    - 스택 주소 지정 방식에 사용되는 특별한 레지스터

    *스택 - 한쪽 끝이 막혀있는 통과 같은 저장 공간. 메모리 안에 있고, 스택 영역이라 한다

* 베이스 레지스터

    - 베이스 레지스터 주소 지정 방식에 사용되는 특별한 레지스터


### 명령어 사이클

* CPU가 하나의 명령어를 처리하는 흐름

* CPU는 명령어 사이클을 반복하며 명령어들을 처리한다

* 인출 사이클, 실행 사이클, 간접 사이클, 인터럽트 사이클로 이루어져 있다

* 인출 사이클

    - 명령어를 메모리에서 CPU로 가져오는 단계

* 실행 사이클

    - CPU로 가져온 명령어를 실행하는 단계

    - 제어장치가 레지스터에 담긴 값을 해석해 제어 신호를 발생시키는 것

* 간접 사이클

    - 오퍼랜더의 필드에 간접 주소 지정 방식을 사용한 경우 메모리에 한번 더 접근


### 인터럽트

* CPU의 정상적인 작업을 방해하는 신호

* 동기 인터럽트와 비동기 인터럽트가 있다

* 동기 인터럽트(예외)

    - CPU에 의해 발생하는 인터럽트

    - CPU가 명령어들을 수행하다 예상치 못한 상황에 마주쳤을때 발생하는 인터럽트

    - 프로그래밍상의 오류와 같은 예외적인 상황일때 발생하기 때문에 예외 라고도 부른다

* 비동기 인터럽트(하드웨어 인터럽트)

    - 입출력장치에 의해 발생하는 인터럽트

    - 알림 역할을 한다

    - ex) 키보드, 마우스와 같은 입출력장치가 어떠한 입력을 받았을때 이를 처리하기 위해 cpu에게 입력 알림을(인터럽트) 보낸다 


### 비동기 인터럽트(하드웨어 인터럽트)

* 입출력 장치에 의해 발생하는 알림과 같은 인터럽트

* cpu가 입출력 작업 도중에도 효율적으로 명령어를 처리하기 위해 사용한다

```
// 하드웨어 인터럽트 사용 이유
1. cpu가 프린터에 출력을 명령

2. 입출력장치는 cpu보다 속도가 느리기 때문에 cpu는 입출력 결과를 바로 받아볼 수 없다

3. cpu는 프린터가 언제 프린터를 끝낼지 모르기 때문에 주기적으로 완료 여부를 확인해야 한다

4. 이로 인해 cpu는 다른 일을 할 수 없으니 cpu 사이클 낭비다

5. 하드웨어 인터럽트 사용 시 cpu는 주기적으로 확인할 필요가 없다

6. 프린터로부터 프린트 완료 인터럽트를 받을 때까지 다른 작업을 처리할 수 있다
```

* 하드웨어 인터럽트 처리 순서

```
// 인터럽트 사이클
1. 입출력장치는 cpu에 인터럽트 요청 신호를 보냄

2. cpu는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인

3. cpu는 인터럽트 요청을 확인하고 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지 확인

4. 있다면 cpu는 지금까지의 작업을 메모리의 스택 공간에 백업

5. cpu는 인터럽트 벡터를 참조하여 (프로그램 카운터 값을 인터럽트 서비스 루틴의 시작 주소가 위치한 곳으로 갱신해) 인터럽트 서비스 루틴 실행

6. 인터럽트 서비스 루틴 실행 종료 시 백업해 둔 작업을 복구하여 실행 재개
```

* 플래그 레지스터의 인터럽트 플래그

    - 인터럽트를 받아들일지 무시할지 결정하는 플래그

    - cpu가 중요한 작업을 처리할 시 불가능으로 설정되고, 그렇게 되면 cpu는 인터럽트 요청을 무시한다

    - 불가능으로 설정되어도 정전이나 고장 같은 우선순위가 높은 인터럽트는 무시하지 못한다


* 인터럽트 서비스 루틴

    - 인터럽를 처리하기 위한 동작들로 이루어진 프로그램

    - 마우스가 어떤 인터럽트 요청 시 이렇게 작동, 키보드가 어떤 인터럽트 요청 시 이렇게 작동 과 같이 해당 인터럽트를 어떻게 처리하고 작동해야 할지에 대한 정보로 이루어짐

    - 메모리에 인터럽트 서비스 루틴들이 저장되어 있다

    - 인터럽트 발생 시 cpu는 인터럽트 서비스 루틴으로 점프해 실행하고 완료 후 기존 작업으로 점프 해 재개한다  

* 인터럽트 벡터

    - 인터럽트 서비스 루틴을 식별하기 위한 정보

    - cpu는 하드웨어 인터럽트 요청을 보낸 대상으로부터 인터럽트 벡터를 전달받는다

    - 인터럽트 벡터로 인터럽트 서비스 루틴의 시작 주소를 알 수 있기 때문에 cpu가 특정 인터럽트 서비스 루틴을 처음부터 실행할 수 있다
