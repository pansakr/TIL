### 명령어의 구조

* 명령어는 연산코드와 오퍼랜드로 구성되어 있다

    - 연산 코드(또는 연산자) : 명령어가 수행할 연산
    
    - ex) 더해라, 빼라, 저장해라

    - 오퍼랜드(또는 피연산자) : 연산에 사용할 데이터 또는 연산에 사용할 데이터가 저장된 위치
    
    - ex) 100과 200을, 메모리 32번지 안의 값과 메모리 33번지 안의 값을 

* 연산 코드가 담기는 영역을 연산코드 필드, 오퍼랜드가 담기는 영역을 오퍼랜드 필드라고 한다

<img src ="오퍼랜드1">


### 오퍼랜드

* 연산에 필요한 데이터 또는 데이터가 저장된 위치

* 연산에 필요한 숫자나 문자의 데이터를 담을 수 있지만 대부분 데이터가 저장된 위치인 메모리 주소나 레지스터 이름이 담기기 때문에 주소 필드라고도 부른다

* 오퍼랜드는 명령어 안에 없거나, 하나만 있거나, 여러개가 있을 수 있다

    - 오퍼랜드가 하나도 없는 명령어 : 0-주소 명령어

    - 오퍼랜드가 하나인 명령어 : 1-주소 명령어

    - 오퍼랜드가 두개, 세 개인 명령어 : 2-주소 명령어, 3-주소 명령어

### 연산 코드

* 명령어가 수행할 연산

* 크게 데이터 전송, 산술/논리 연산, 제어 흐름 변경, 입출력 제어 4가지로 나눌 수 있다

* 명령어의 종류는 CPU마다 다르기 때문에 연산 코드의 종류도 CPU마다 다르다

* 아래는 CPU가 공통으로 이해하는 대표적인 연산 코드의 종류이다

* 데이터 전송

    - MOVE : 데이터를 옮겨라

    - STORE : 메모리에 저장하라

    - LOAD(FETCH): 메모리에서 CPU로 데이터를 가져와라

* 산술/논리 연산

    - ADD / SUBTRACT / MULTIPLY / DIVIDE : 덧셈, 뺄셈, 곱셈, 나눗셈을 수행해라

* 제어 흐름 변경

    - JUMP : 특정 주소로 실행 순서를 옮겨라

    - HALT : 프로그램의 실행을 멈춰라

* 입출력 제어

    - READ(INPUT) : 특정 입출력 장치로부터 데이터를 읽어라

    - WRITE(OUTPUT) : 특정 입출력 장치로 데이터를 써라

    - START IO : 입출력 장치를 시작해라

    - TEST IO : 입출력 장치의 상태를 확인해라


### 주소 지정 방식

* 오퍼랜드 필드에 담을 데이터를 명시하는 방식

* 유효 주소 - 연산에 사용할 데이터가 저장된 위치

* 오퍼랜드 필드에 데이터보다 메모리나 레지스터의 주소를 명시하는 이유는 명령어의 길이 때문이다

```
1. 명령어의 크기가 16비트, 그중 연산 코드가 4비트인 2-주소 명령어는 오퍼랜드 필드당 6비트밖에 남지 않는다

2. 하나의 오퍼랜드 필드로 표현할 수 있는 정보의 가짓수는 2의 6제곱 밖에 되지 않는다

3. 반면 한 주소에 16비트를 저장할 수 있는 메모리가 있다고 할때
    
4. 이 메모리에 데이터를 저장하고, 오퍼랜드 필드에 해당 메모리 주소를 명시한다면 표현할 수 있는 정보의 가짓수는 2의 16제곱으로 확 커진다 

5. 레지스터의 이름을 명시한다면 표현할 수 있는 정보의 가짓수는 해당 레지스터가 저장할 수 있는 공간만큼 커진다
```
